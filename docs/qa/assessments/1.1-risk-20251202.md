# **Enhanced** Risk Profile: Story 1.1: Project Setup & Monorepo Structure

**Date**: 2025-12-02  
**Reviewer**: Quinn (Senior Test Architect)  
**Status**: Updated & Finalized for Architect Review

## 1. Executive Summary

This assessment provides a comprehensive, actionable risk profile for Story 1.1. The initial setup is the most critical part of the project; errors here will cascade and compound. The previous risk assessment was insufficient. This enhanced profile identifies **4 High-Priority** and **3 Medium-Priority** risks.

The primary directive is to move from high-level suggestions to **concrete, implementable mitigation strategies**. The "Mitigation & Implementation" sections below are designed to be copied directly into the `Dev Notes` of Story 1.1 by the Architect Agent to ensure a hardened, reliable foundation.

- **Total Risks Identified**: 7
- **Critical Risks (Score 9)**: 1
- **High Risks (Score 6-8)**: 3
- **Medium Risks (Score 4-5)**: 3
- **Overall Assessment**: **NO-GO** until all High/Critical risk mitigations are integrated into the story.

## 2. Detailed Risk Register

| Risk ID | Description | Category | Probability (1-3) | Impact (1-3) | Score (P√óI) | Priority |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **TECH-001** | **Monorepo Workspace Resolution Failure** | Technical | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **OPS-001** | **Git Hooks Blocking Developer Workflow** | Operational | 3 (High) | 2 (Medium) | **6** | **HIGH** |
| **DEV-001** | **Developer Environment Divergence** | Operational | 3 (High) | 2 (Medium) | **6** | **HIGH** |
| **OPS-002** | **Build & CI Scripts Failing Silently** | Operational | 2 (Medium) | 3 (High) | **6** | **HIGH** |
| **TECH-002** | **TypeScript Strict Mode & 3rd-Party Types** | Technical | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |
| **TECH-003** | **ESLint/Prettier Rule Conflicts** | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |
| **TECH-006** | **Configuration Complexity & Brittleness**| Technical | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |

---

## 3. Actionable Mitigation & Implementation Plan

**This section is for the Architect Agent.** Copy the following subsections directly into the `Dev Notes` of `1.1.story.md` under a `### Risk Mitigation Strategies` heading.

---

### **CRITICAL RISK: Monorepo Workspace Resolution (TECH-001)**
**Problem**: `pnpm` workspace resolution is powerful but can fail cryptically, causing broken cross-package imports (`@shared/`) and build failures that are hard to debug. This is the highest technical risk.

**Mitigation & Implementation**:
1.  **Use Explicit Workspace Protocol**: Enforce the `workspace:*` protocol in all `package.json` files for internal dependencies. This ensures `pnpm` uses the local workspace package instead of a potentially mismatched version from the registry.
    *   **Action**: In `backend/package.json` and `dashboard/package.json`, dependencies on `shared` must be:
        ```json
        "dependencies": {
          "@shared/types": "workspace:*"
        }
        ```
2.  **Create a Verification Script**: Add a dedicated script to verify that cross-package imports resolve and execute correctly. This acts as a smoke test for the monorepo setup.
    *   **Action**: Create `scripts/verify-workspace.ts`:
        ```typescript
        // scripts/verify-workspace.ts
        import { SOME_CONSTANT } from '@shared/constants';
        import { SomeType } from '@shared/types';

        console.log('‚úÖ Successfully imported SOME_CONSTANT:', SOME_CONSTANT);
        const testVar: SomeType = { id: '1', name: 'test' };
        console.log('‚úÖ Successfully typed with SomeType:', testVar);
        console.log('üéâ Workspace resolution is working correctly!');
        ```
    *   **Action**: Add a `verify:workspace` script to the root `package.json`:
        ```json
        "scripts": {
          "verify:workspace": "tsx scripts/verify-workspace.ts"
        }
        ```
3.  **Centralize CI Build Command**: Ensure CI uses a recursive, error-propagating build command.
    *   **Action**: The root `build` script must be: `"build": "pnpm -r --workspace-concurrency=1 run build"`. The `--workspace-concurrency=1` flag ensures logs are sequential and readable.

### **HIGH RISK: Git Hooks Blocking Developer Workflow (OPS-001)**
**Problem**: Overly aggressive or slow Husky hooks can block commits/pushes during emergencies or tight deadlines, leading developers to bypass them entirely and defeat their purpose.

**Mitigation & Implementation**:
1.  **Provide Clear Bypass Instructions**: Hooks must fail with informative messages that tell the developer *how* to bypass them.
    *   **Action**: Add the following pattern to the top of every hook script (e.g., `.husky/pre-commit`):
        ```bash
        #!/usr/bin/env sh
        . "$(dirname -- "$0")/_/husky.sh"

        echo "üõ°Ô∏è Running pre-commit checks..."
        echo "üí° TIP: To bypass, run 'git commit --no-verify'"

        # Example for pre-commit
        pnpm lint-staged || {
          echo "‚ùå Pre-commit checks failed. Please fix the issues above."
          echo "üí° To bypass this check in an emergency, run: git commit --no-verify"
          exit 1
        }
        echo "‚úÖ Pre-commit checks passed."
        ```
2.  **Optimize Hook Speed**: Use `lint-staged` to ensure hooks only operate on changed files, not the entire codebase. This is critical for keeping commit times fast.
    *   **Action**: Add a `lint-staged` configuration to the root `package.json`:
        ```json
        "lint-staged": {
          "*.{ts,tsx}": [
            "eslint --fix",
            "prettier --write"
          ],
          "*.{js,jsx,json,md}": "prettier --write"
        }
        ```

### **HIGH RISK: Developer Environment Divergence (DEV-001)**
**Problem**: Developers using different Node.js or `pnpm` versions can cause subtle bugs, inconsistent behavior, and "works on my machine" issues.

**Mitigation & Implementation**:
1.  **Enforce Engine Versions**: Use the `engines` field in the root `package.json` to specify exact Node and pnpm versions. This will cause `pnpm install` to fail if the versions don't match.
    *   **Action**: Add to root `package.json`:
        ```json
        "engines": {
          "node": ">=24.11.1",
          "pnpm": ">=10.0.0"
        }
        ```
    *   **Action**: To enforce this, create a `.npmrc` file in the root with `engine-strict=true`.
2.  **VS Code Extension Recommendations**: While not enforceable, providing workspace recommendations nudges developers to install critical extensions (ESLint, Prettier).
    *   **Action**: Create `.vscode/extensions.json`:
        ```json
        {
          "recommendations": [
            "dbaeumer.vscode-eslint",
            "esbenp.prettier-vscode",
            "bradlc.vscode-tailwindcss",
            "prisma.prisma",
            "vitest.explorer"
          ]
        }
        ```

### **HIGH RISK: Build & CI Scripts Failing Silently (OPS-002)**
**Problem**: Build failures within the monorepo can be hidden if the root script doesn't correctly propagate exit codes, leading to deployments of broken code.

**Mitigation & Implementation**:
1.  **Create a Build Verification Script**: A post-build script should check that the expected artifacts were actually created.
    *   **Action**: Create `scripts/verify-build.js`:
        ```javascript
        const fs = require('fs');
        const path = require('path');
        const requiredOutputs = [
          'backend/dist/index.js',
          'dashboard/.next/BUILD_ID',
          'shared/dist/index.js',
        ];
        console.log('üîç Verifying build outputs...');
        const notFound = requiredOutputs.filter(
          (p) => !fs.existsSync(path.join(__dirname, '..', p))
        );
        if (notFound.length > 0) {
          console.error(`‚ùå Build verification failed! Missing outputs:`, notFound);
          process.exit(1);
        }
        console.log('‚úÖ All build outputs found.');
        ```
    *   **Action**: Add a `postbuild` script to the root `package.json` to run this automatically after every build.
        ```json
        "scripts": {
          "build": "pnpm -r --workspace-concurrency=1 run build",
          "postbuild": "node scripts/verify-build.js"
        }
        ```

### **MEDIUM RISK: TypeScript Strict Mode & 3rd-Party Types (TECH-002)**
**Problem**: The project's strict TypeScript settings can cause build failures when using third-party libraries that have poor or incorrect type definitions.

**Mitigation & Implementation**:
1.  **Use Declaration Files for Overrides**: Create dedicated `.d.ts` files to override or augment problematic third-party types. This is cleaner than using `@ts-ignore`.
    *   **Action**: Create `backend/src/types/overrides.d.ts`. Add a documented example for how a developer should handle this.
        ```typescript
        // backend/src/types/overrides.d.ts

        /*
         * This file contains TypeScript declaration overrides for third-party libraries.
         * Use this to fix incorrect or missing types from dependencies.
         *
         * Example for a hypothetical library 'some-lib':
         * declare module 'some-lib' {
         *   export interface ProblematicInterface {
         *     correctedProperty: string; // Was missing or wrong type
         *   }
         * }
        */
        ```
    *   **Action**: Ensure `tsconfig.json` includes this file.

### **MEDIUM RISK: ESLint/Prettier Rule Conflicts (TECH-003)**
**Problem**: ESLint's formatting rules can conflict with Prettier, leading to infinite loops in format-on-save and CI failures.

**Mitigation & Implementation**:
1.  **Use `eslint-config-prettier`**: This package disables all ESLint rules that are unnecessary or might conflict with Prettier.
    *   **Action**: Ensure `eslint-config-prettier` is the **last** item in the `extends` array of `.eslintrc.js` to ensure it correctly overrides other configs.
        ```javascript
        // .eslintrc.js
        module.exports = {
          // ...
          extends: [
            'eslint:recommended',
            'plugin:@typescript-eslint/recommended',
            // ... other configs ...
            'prettier', // MUST BE LAST
          ],
        };
        ```
2.  **Create a Validation Script**: A single script should run all format, lint, and type checks in the correct order.
    *   **Action**: Add a `validate` script to the root `package.json`:
        ```json
        "scripts": {
          "validate": "pnpm format:check && pnpm lint && pnpm typecheck"
        }
        ```

### **MEDIUM RISK: Configuration Complexity & Brittleness (TECH-006)**
**Problem**: The project has numerous configuration files. A change in one place (e.g., a path in `tsconfig.json`) can break another (e.g., `vitest.config.ts`) without an obvious error.

**Mitigation & Implementation**:
1.  **Centralize Path Aliases**: Define path aliases in `tsconfig.base.json` and ensure other tools (like Vitest) read from it to avoid duplication.
    *   **Action**: Update `vitest.config.ts` to use `tsconfig-paths` to automatically read aliases from `tsconfig.json`.
        ```typescript
        // vitest.config.ts
        import { defineConfig } from 'vitest/config';
        import tsconfigPaths from 'vitest-tsconfig-paths';

        export default defineConfig({
          plugins: [tsconfigPaths()], // This plugin reads aliases from tsconfig
          test: {
            // ...
          },
        });
        ```
2.  **Add Configuration Comments**: Add comments to all configuration files explaining *why* a setting is a certain way, especially if it's non-obvious or related to another file.
    *   **Action**: Mandate that all non-trivial configuration options are commented. For example:
        ```json
        // tsconfig.base.json
        {
          "compilerOptions": {
            // Enables tools like Vitest to resolve '@/' paths
            "baseUrl": ".",
            "paths": {
              "@/*": ["./src/*"],
              "@shared/*": ["../shared/src/*"]
            }
          }
        }
        ```