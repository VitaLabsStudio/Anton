# **Enhanced** Risk Profile: Story 1.4: Twitter/X API Authentication

**Date**: 2025-12-02  
**Reviewer**: Quinn (Senior Test Architect)  
**Status**: Updated & Finalized for Architect Review

## 1. Executive Summary

This enhanced risk profile for Story 1.4 addresses the integration with the Twitter API. The initial assessment correctly identified the major flaws, but this update provides **prescriptive, copy-paste-ready implementation plans** to correct them.

This assessment elevates the **Ineffective Rate Limiting Logic (OPS-001)** to **CRITICAL**. The use of a blocking `sleep()` call is a fundamental architectural flaw that would cause catastrophic server failure under load. This is **Primary Directive #2** and its mitigation is non-negotiable.

Additionally, **Credential Leakage (SEC-001)** remains a **CRITICAL** risk. This document provides hardened, multi-layer mitigations. All high-priority risks have been updated with direct implementation guidance for the Architect Agent.

- **Total Risks Identified**: 5
- **Critical Risks (Score 9)**: 2
- **High Risks (Score 6-8)**: 2
- **Medium Risks (Score 4-5)**: 1
- **Overall Assessment**: **NO-GO**. The story is fundamentally flawed and unsafe. The Architect Agent must incorporate these mitigations.

## 2. Detailed Risk Register

| Risk ID | Description | Category | Probability (1-3) | Impact (1-3) | Score (PÃ—I) | Priority |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **SEC-001** | **Credential Leakage via Accidental Git Commit** | Security | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **OPS-001** | **Server Hang due to Blocking Rate Limiter** | Operational | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **BUS-001** | **Permanent Suspension of Twitter API Access** | Business | 2 (Medium) | 3 (High) | **6** | **HIGH** |
| **TECH-001**| **Brittle Circuit Breaker Trips on Client Errors** | Technical | 2 (Medium) | 3 (High) | **6** | **HIGH** |
| **LOG-001** | **Insufficient Logging for API Failures** | Operational | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |

---

## 3. Actionable Mitigation & Implementation Plan

**This section is for the Architect Agent.** Copy the following subsections directly into the `Dev Notes` of `1.4.story.md`, replacing the existing `Risk Mitigation Strategies` section.

---

### **CRITICAL RISK: Credential Leakage (SEC-001)**
**Problem**: Leaking API keys is an existential threat to the service. Relying on `.gitignore` alone is insufficient.

**Mitigation & Implementation**:
1.  **Use Centralized Secret Management**: This is covered in Story 1.3 but must be reinforced here. The `auth.ts` module must *only* read from `process.env` and never from files.
2.  **Implement Pre-Commit Secret Scanning**: Use `gitleaks` to prevent secrets from ever entering the repository.
    *   **Action**: Create `.gitleaks.toml` in the root directory with Twitter-specific rules.
        ```toml
        # .gitleaks.toml
        title = "Gitleaks Base Configuration"
        
        [[rules]]
        id = "twitter-api-key"
        description = "Twitter API Key"
        regex = '''(?i)(twitter[_-]?api[_-]?key|twitter[_-]?consumer[_-]?key)\s*[:=]\s*['"]?([a-zA-Z0-9]{18,25})['"]?'''
        tags = ["key", "twitter"]

        [[rules]]
        id = "twitter-api-secret"
        description = "Twitter API Secret"
        regex = '''(?i)(twitter[_-]?api[_-]?secret|twitter[_-]?consumer[_-]?secret)\s*[:=]\s*['"]?([a-zA-Z0-9]{35,50})['"]?'''
        tags = ["key", "twitter"]

        [[rules]]
        id = "twitter-access-token"
        description = "Twitter Access Token"
        regex = '''(?i)(twitter[_-]?access[_-]?token)\s*[:=]\s*['"]?([0-9]+-[a-zA-Z0-9]{40})['"]?'''
        tags = ["key", "twitter"]
        ```
    *   **Action**: The CI pipeline from story 1.3 (`secret-scan.yml`) will automatically pick this up.

### **CRITICAL RISK: Server Hang due to Blocking Rate Limiter (OPS-001) - PRIMARY DIRECTIVE #2**
**Problem**: The proposed `RateLimiter` design using `sleep()` is an architectural disaster. It will block the entire Node.js event loop, freezing the server under any real load. **It must be completely replaced.**

**Mitigation & Implementation**:
1.  **Replace with a Production-Grade, Non-Blocking Library**: Use the `bottleneck` library. It uses a job queue and is designed for high-performance Node.js applications.
    *   **Action**: Add `bottleneck` to dependencies.
        ```bash
        pnpm add bottleneck && pnpm add -D @types/bottleneck
        ```
    *   **Action**: **Replace the entire `rate-limiter.ts` file** with this non-blocking implementation:
        ```typescript
        // backend/src/utils/rate-limiter.ts
        import Bottleneck from 'bottleneck';
        import { logger } from './logger';

        export class RateLimiter {
          private readonly readLimiter: Bottleneck;
          private readonly writeLimiter: Bottleneck;

          constructor() {
            // Twitter Read Limit: 900 reqs / 15 min
            this.readLimiter = new Bottleneck({
              reservoir: 900,
              reservoirRefreshAmount: 900,
              reservoirRefreshInterval: 15 * 60 * 1000,
              maxConcurrent: 10,
            });
            this.configureEvents('Read', this.readLimiter);

            // Twitter Write Limit: 300 reqs / 15 min
            this.writeLimiter = new Bottleneck({
              reservoir: 300,
              reservoirRefreshAmount: 300,
              reservoirRefreshInterval: 15 * 60 * 1000,
              maxConcurrent: 5,
            });
            this.configureEvents('Write', this.writeLimiter);
          }

          private configureEvents(type: string, limiter: Bottleneck) {
            limiter.on('depleted', () => logger.warn(`${type} rate limit depleted. Queuing subsequent requests.`));
            limiter.on('idle', () => logger.info(`${type} rate limiter queue is now idle.`));
          }

          scheduleRead<T>(fn: () => Promise<T>): Promise<T> {
            return this.readLimiter.schedule(fn);
          }

          scheduleWrite<T>(fn: () => Promise<T>): Promise<T> {
            return this.writeLimiter.schedule(fn);
          }
          
          getStatus() {
            return { read: this.readLimiter.counts(), write: this.writeLimiter.counts() };
          }
        }
        
        export const twitterRateLimiter = new RateLimiter();
        ```
    *   **Action**: The `TwitterClient` must be updated to use the new `schedule` methods. The `acquire` method no longer exists.
        ```typescript
        // In TwitterClient class
        async search(query: string): Promise<Tweet[]> {
          return twitterRateLimiter.scheduleRead(() => {
            // ... circuit breaker and API call logic ...
          });
        }
        
        async reply(tweetId: string, content: string): Promise<void> {
          return twitterRateLimiter.scheduleWrite(() => {
            // ... circuit breaker and API call logic ...
          });
        }
        ```

### **HIGH RISK: Suspension of Twitter API Access (BUS-001)**
**Problem**: A bug causing spammy behavior or posting prohibited content could lead to a permanent API ban, destroying the product's value.

**Mitigation & Implementation**:
1.  **Implement a Global "Dry Run" Mode**: This switch prevents the application from making any state-changing API calls (e.g., posting a reply).
    *   **Action**: Create `backend/src/config/app.config.ts`:
        ```typescript
        export const appConfig = {
          isDryRun: process.env.DRY_RUN === 'true', // Default to OFF unless specified
        };
        ```
    *   **Action**: In the `TwitterClient.reply` method, check this flag before executing the API call.
        ```typescript
        // In TwitterClient.reply()
        if (appConfig.isDryRun) {
          logger.info({ tweetId, content }, '[DRY RUN] Reply not sent.');
          return; // Or return a mock response
        }
        // ... proceed to scheduleWrite ...
        ```
2.  **Monitor for Policy Violations**: Actively detect HTTP `403 Forbidden` errors, which strongly indicate a policy violation.
    *   **Action**: Add specific error handling inside the `TwitterClient.reply` method.
        ```typescript
        // Inside the scheduled write function in reply()
        try {
          // ... await this.client.v2.reply(...) ...
        } catch (error: any) {
          if (error?.code === 403) {
            logger.fatal({ error, tweetId }, 'CRITICAL: Twitter API returned 403 Forbidden. Possible policy violation. Manual intervention required.');
            // TODO: Trigger alert to high-priority channel (Story 1.8)
          }
          throw error;
        }
        ```

### **HIGH RISK: Brittle Circuit Breaker (TECH-001)**
**Problem**: The proposed circuit breaker is naive. It will trip on client-side `4xx` errors (e.g., "Tweet not found"), unnecessarily blocking calls to a healthy Twitter API.

**Mitigation & Implementation**:
1.  **Make the Circuit Breaker Error-Aware**: It must only trip on systemic failures (network errors, `5xx` server errors, `429` rate limit errors).
    *   **Action**: **Replace the `CircuitBreaker` implementation** with this intelligent version:
        ```typescript
        // backend/src/utils/circuit-breaker.ts
        import { logger } from './logger';
        // ... (same state and config types as before)

        export class CircuitBreaker {
          // ... (properties are the same)
          
          private isSystemicError(error: any): boolean {
            if (!error.code && !error.statusCode) return true; // Generic errors
            if (['ECONNRESET', 'ETIMEDOUT'].includes(error.code)) return true; // Network errors
            if (error.statusCode >= 500) return true; // 5xx Server Errors
            if (error.statusCode === 429) return true; // Rate limiting is systemic
            return false; // 4xx Client Errors are NOT systemic
          }

          async execute<T>(fn: () => Promise<T>): Promise<T> {
            if (this.state === 'OPEN') {
              // ... (same logic as before) ...
            }
            try {
              const result = await fn();
              this.onSuccess();
              return result;
            } catch (error) {
              if (this.isSystemicError(error)) {
                this.onFailure();
              } else {
                logger.warn({ error }, 'Non-systemic client error. Circuit breaker will not trip.');
              }
              throw error;
            }
          }
          // ... (onSuccess and onFailure methods are the same) ...
        }
        ```

---
## 4. Final Recommendation

Story 1.4 is **NO-GO**. The `sleep()`-based rate limiter is a critical design flaw that must be ripped out and replaced with the non-blocking `bottleneck` implementation provided. The Architect Agent must replace the relevant sections in `Dev Notes` with the detailed plans above to address the critical risks before this story can be safely implemented.