# Enhanced Risk Profile: Story 1.6: Threads API Authentication

**Date**: 2025-12-02  
**Reviewer**: Quinn (Test Architect)  
**Status**: Updated & Finalized for Architect Review

## 1. Executive Summary

This enhanced risk profile for Story 1.6 addresses the integration with the new and volatile Threads API. The primary risk is not just authentication, but building a client that is resilient to the API's inevitable changes, instability, and feature limitations.

The initial assessment correctly identified the major risk categories. This update provides a **complete architectural pattern** to mitigate them, centered around **defensive coding through abstraction and validation**. The mitigations are prescriptive and include copy-paste-ready code for the Architect Agent.

- **Total Risks Identified**: 5
- **Critical Risks (Score 9)**: 2 (Credential Leakage, API Volatility)
- **High Risks (Score 6-8)**: 3
- **Overall Assessment**: **NO-GO**. The story requires a more robust architectural foundation to avoid creating a brittle, unmaintainable client. The Architect Agent must implement the patterns defined herein.

## 2. Detailed Risk Register

| Risk ID | Description | Category | Probability (1-3) | Impact (1-3) | Score (PÃ—I) | Priority |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **SEC-001** | **Leaked Threads Access Token via Git Commit** | Security | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **TECH-001**| **API Volatility & Breaking Changes** | Technical | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **TECH-003**| **Permanent Auth Failure on Token Expiration** | Technical | 3 (High) | 2 (Medium) | **6** | **HIGH** |
| **DEV-001** | **Implementation Bugs due to No SDK** | Technical | 3 (High) | 2 (Medium) | **6** | **HIGH** |
| **OPS-001** | **Reusing Flawed/Inconsistent Utilities** | Operational | 2 (Medium) | 3 (High) | **6** | **HIGH** |

---

## 3. Actionable Mitigation & Implementation Plan

**This section is for the Architect Agent.** The following architectural patterns and implementations must be integrated into the `Dev Notes` and `Tasks` of Story 1.6.

---

### **CRITICAL RISK: API Volatility & Breaking Changes (TECH-001)**
**Problem**: The Threads API is new and its responses and behavior are subject to unannounced changes. Hard-coding the client to the current API structure will create an incredibly brittle system that breaks silently.

**Mitigation & Implementation**:
1.  **Define a Generic Platform Interface**: Abstract the platform-specific logic behind a common interface. This forces consistency and insulates the core application from platform-specific implementation details.
    *   **Action**: Create `backend/src/platforms/IPlatformClient.ts`:
        ```typescript
        // IPlatformClient.ts
        export interface Post { id: string; content: string; author: { id: string; name: string; }; }
        export interface ClientStatus { available: boolean; message: string; }

        export interface IPlatformClient {
          verifyCredentials(): Promise<ClientStatus>;
          search(query: string): Promise<Post[]>;
          reply(postId: string, content: string): Promise<{ replyId: string }>;
        }
        ```
    *   **Action**: The `ThreadsClient`, `TwitterClient`, and `RedditClient` classes MUST all `implement IPlatformClient`.

2.  **Mandate Runtime Response Validation with Zod**: Every response from the Threads API must be parsed by a Zod schema. If the API response changes, the Zod parser will throw an explicit error, preventing malformed data from propagating and immediately identifying the breaking change.
    *   **Action**: Create `backend/src/platforms/threads/threads.schemas.ts`:
        ```typescript
        import { z } from 'zod';

        // Define a Zod schema for the expected API response
        const ZodThreadsPost = z.object({
          id: z.string(),
          text: z.string(),
          author: z.object({
            id: z.string(),
            username: z.string(),
          }),
        });
        
        export const ZodThreadsSearchResponse = z.object({
          data: z.array(ZodThreadsPost),
        });

        // Adapter function to convert API response to our internal Post model
        export function toInternalPost(thread: z.infer<typeof ZodThreadsPost>): Post {
          return {
            id: thread.id,
            content: thread.text,
            author: { id: thread.author.id, name: thread.author.username },
          };
        }
        ```
    *   **Action**: The `ThreadsClient.search` method **MUST** use this parser.
        ```typescript
        // In ThreadsClient.search()
        const response = await this.client.get('/threads/search', { params: { q: query }});
        
        // Validate and parse the response. This will throw if the API changes.
        const parsedResponse = ZodThreadsSearchResponse.parse(response.data);

        // Convert the validated API data to our internal, consistent Post model.
        return parsedResponse.data.map(toInternalPost);
        ```

### **CRITICAL RISK: Credential Leakage (SEC-001)**
**Problem**: A leaked Threads/Meta access token provides direct access to the account.

**Mitigation & Implementation**:
1.  **Implement Threads-Specific Secret Scanning**: Add `gitleaks` rules for Meta-style tokens.
    *   **Action**: Add to `.gitleaks.toml`:
        ```toml
        [[rules]]
        id = "meta-access-token"
        description = "Meta/Facebook/Instagram/Threads Access Token"
        # Catches long-lived tokens starting with EAA
        regex = '''EAA[a-zA-Z0-9-]{150,}'''
        tags = ["key", "meta", "threads"]
        ```

### **HIGH RISK: Permanent Auth Failure on Token Expiration (TECH-003)**
**Problem**: Long-lived tokens expire (typically after 60 days). The application needs to refresh them automatically *before* they expire to prevent an outage.

**Mitigation & Implementation**:
1.  **Implement an Axios Interceptor for Token Refresh**: An interceptor can catch `401 Unauthorized` errors, perform a token refresh, and then automatically retry the original failed request with the new token. This is a robust, standard pattern.
    *   **Action**: Provide this implementation for the `ThreadsClient`:
        ```typescript
        // backend/src/platforms/threads/client.ts
        import axios, { AxiosError, AxiosInstance } from 'axios';

        // ... other imports

        export class ThreadsClient implements IPlatformClient {
          private client: AxiosInstance;
          
          constructor() {
            this.client = axios.create({ baseURL: 'https://graph.threads.net/v1.0' });
            
            // Add the interceptor
            this.client.interceptors.response.use(
              (response) => response, // Pass through successful responses
              this.handleApiError.bind(this) // Handle errors
            );
          }

          private async handleApiError(error: AxiosError) {
            const originalRequest = error.config;
            if (error.response?.status === 401 && originalRequest && !originalRequest._isRetry) {
              originalRequest._isRetry = true; // Prevent infinite retry loops
              try {
                logger.warn('Threads access token expired or invalid. Attempting refresh...');
                const newToken = await this.refreshToken();
                // Update the header for the retried request
                originalRequest.headers['Authorization'] = `Bearer ${newToken}`;
                return this.client(originalRequest); // Retry the original request
              } catch (refreshError) {
                logger.fatal({ refreshError }, 'Failed to refresh Threads token. Manual intervention required.');
                // TODO: Disable client, send alert
                return Promise.reject(refreshError);
              }
            }
            return Promise.reject(error);
          }

          private async refreshToken(): Promise<string> {
            // This logic should call the Meta Graph API to get a new long-lived token
            // and securely persist it using the secret manager from Story 1.3.
            // For now, we simulate it.
            const newAccessToken = `refreshed_${Date.now()}`;
            process.env.THREADS_ACCESS_TOKEN = newAccessToken; // Update in-memory token
            // await secretManager.setSecret('THREADS_ACCESS_TOKEN', newAccessToken);
            logger.info('Successfully refreshed Threads access token.');
            return newAccessToken;
          }
          
          // ... implementation of search, reply, etc.
        }
        ```

### **HIGH RISK: Implementation Bugs due to No SDK (DEV-001)**
**Problem**: Writing raw API calls is error-prone. Without an SDK, developers must manually handle endpoints, parameters, headers, and error formats.

**Mitigation & Implementation**:
1.  **Provide a Clear and Robust Class Skeleton**: The `Dev Notes` should provide a complete skeleton for the `ThreadsClient`, showing exactly how the `IPlatformClient` interface, rate limiter, circuit breaker, and Zod validation should be integrated.
    *   **Action**: The `Dev Notes` must include this full client structure:
        ```typescript
        // backend/src/platforms/threads/client.ts
        export class ThreadsClient implements IPlatformClient {
          private client: AxiosInstance;
          private readonly circuitBreaker: CircuitBreaker;

          constructor() {
            // ... interceptor setup from TECH-003 ...
            this.circuitBreaker = new CircuitBreaker({ threshold: 5, timeout: 300000 }); // 5 min timeout
          }
          
          async verifyCredentials(): Promise<ClientStatus> { /* ... */ }

          async search(query: string): Promise<Post[]> {
            // 1. Check circuit breaker state
            // 2. Schedule with rate limiter
            return threadsRateLimiter.scheduleRead(() => 
              this.circuitBreaker.execute(async () => {
                // 3. Make API call
                const response = await this.client.get('/threads/search', { params: { q: query } });
                // 4. Validate with Zod
                const parsed = ZodThreadsSearchResponse.parse(response.data);
                // 5. Adapt to internal model
                return parsed.data.map(toInternalPost);
              })
            );
          }
          async reply(postId: string, content: string): Promise<{ replyId: string }> { /* ... */ }
        }
        ```

### **HIGH RISK: Reusing Flawed/Inconsistent Utilities (OPS-001)**
**Problem**: This client could be built with the old, flawed `sleep()`-based rate limiter.

**Mitigation & Implementation**:
1.  **Mandate Correct Utility Usage**: Explicitly require the use of the corrected, `bottleneck`-based `RateLimiter` and the intelligent `CircuitBreaker`.
    *   **Action**: Add to `Dev Notes`: "This client MUST use the non-blocking `RateLimiter` class and error-aware `CircuitBreaker` class defined in the Story 1.4 assessment. Create a new instance configured for Threads API limits."
    *   **Action**: Provide the instantiation code:
        ```typescript
        // In rate-limiter.ts
        export const threadsRateLimiter = new RateLimiter({
          // Threads API allows 200 requests per hour
          read: { maxRequests: 200, windowMs: 60 * 60 * 1000 },
          write: { maxRequests: 200, windowMs: 60 * 60 * 1000 },
        });
        ```

---
## 4. Final Recommendation

Story 1.6 is **NO-GO**. The risk of building a brittle client against a new API is too high. The Architect Agent must adopt the proposed defensive architecture: use the `IPlatformClient` interface, mandate Zod validation for all responses, and provide the robust `axios` interceptor for token management. These patterns are essential for a maintainable and resilient system.
