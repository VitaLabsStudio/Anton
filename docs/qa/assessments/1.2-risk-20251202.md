# **Enhanced** Risk Profile: Story 1.2: Docker Compose Infrastructure Setup

**Date**: 2025-12-02  
**Reviewer**: Quinn (Senior Test Architect)  
**Status**: Updated & Finalized for Architect Review

## 1. Executive Summary

This enhanced risk profile for Story 1.2 addresses the foundational Docker infrastructure. The initial assessment correctly identified `OPS-001` (Deployment Failures) as a critical risk but lacked the actionable detail required for effective mitigation. This update provides **copy-paste-ready implementation plans** for the Architect Agent to integrate directly into the story's `Dev Notes`.

I have identified **2 CRITICAL** and **3 HIGH** priority risks. The most significant are the risk of **accidental data loss** via volume mismanagement and the brittleness of the Docker build process in a `pnpm` monorepo. The mitigations provided below are mandatory to ensure a stable and safe development environment.

- **Total Risks Identified**: 8
- **Critical Risks (Score 9)**: 2
- **High Risks (Score 6-8)**: 3
- **Medium Risks (Score 4-5)**: 3
- **Overall Assessment**: **NO-GO**. The story cannot proceed until the Architect Agent incorporates these detailed mitigations.

## 2. Detailed Risk Register

| Risk ID | Description | Category | Probability (1-3) | Impact (1-3) | Score (PÃ—I) | Priority |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **DATA-001**| **Irreversible Data Loss with `docker-compose down -v`** | Data | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **OPS-001** | **Docker Compose Deployment & Health Check Failures**| Operational | 3 (High) | 3 (High) | **9** | **CRITICAL** |
| **TECH-001**| **Monorepo Dockerfile Build Failures** | Technical | 2 (Medium) | 3 (High) | **6** | **HIGH** |
| **SEC-001** | **Leaking Secrets into Docker Image Layers** | Security | 2 (Medium) | 3 (High) | **6** | **HIGH** |
| **PERF-001**| **Inefficient Docker Layer Caching Slowing Builds** | Performance | 3 (High) | 2 (Medium) | **6** | **HIGH** |
| **CONFIG-001**| **`.env.example` Mismatch with `docker-compose.yml`** | Technical | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |
| **TECH-002**| **Inter-Service Network Connectivity Issues** | Technical | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |
| **OPS-003** | **Backup & Restore Script Failures** | Operational | 2 (Medium) | 2 (Medium) | **4** | **MEDIUM** |

---

## 3. Actionable Mitigation & Implementation Plan

**This section is for the Architect Agent.** Copy the following subsections directly into the `Dev Notes` of `1.2.story.md`, replacing the existing `Risk Mitigation Strategies` section.

---

### **CRITICAL RISK: Irreversible Data Loss (DATA-001)**
**Problem**: A developer running `docker-compose down -v` will instantly and irreversibly delete the entire PostgreSQL database. This is the single most destructive potential error.

**Mitigation & Implementation**:
1.  **Use External Volumes with Warnings**: Switch from default Docker volumes to an "external" volume defined outside the main compose file. This makes accidental deletion harder.
    *   **Action**: Create a separate `docker/volumes.yml` file:
        ```yaml
        # docker/volumes.yml
        volumes:
          postgres_data:
            name: antone_postgres_data # Explicitly name the volume
        ```
    *   **Action**: Update `docker/docker-compose.yml` to use the external volume:
        ```yaml
        # docker/docker-compose.yml
        services:
          postgres:
            # ...
            volumes:
              - postgres_data:/var/lib/postgresql/data
        volumes:
          postgres_data:
            external: true # This prevents 'down -v' from deleting it
        ```
2.  **Create a Safety Wrapper Script**: Create a wrapper script `dev-ctl.sh` (Developer Control) as the primary interface for Docker commands. This script can intercept dangerous commands and force confirmation.
    *   **Action**: Create `scripts/dev-ctl.sh`:
        ```bash
        #!/bin/bash
        set -euo pipefail

        COMMAND="$1"
        shift

        # Block dangerous commands
        if [[ "$COMMAND" == "down" && ( "$*" == "-v" || "$*" == "--volumes" ) ]]; then
          echo "ðŸš¨ CRITICAL: You are attempting to delete all Docker volumes, including the database."
          read -p "Are you sure? This cannot be undone. (y/N): " -r REPLY
          if [[ ! "$REPLY" =~ ^[yY]$ ]]; then
            echo "Aborted."
            exit 1
          fi
        fi

        echo "ðŸš€ Executing: docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml $COMMAND $*"
        docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml "$COMMAND" "$@"
        ```
    *   **Action**: Update `README.md` to instruct developers to use `scripts/dev-ctl.sh up` and `scripts/dev-ctl.sh down` instead of raw `docker-compose`.

### **CRITICAL RISK: Deployment & Health Check Failures (OPS-001)**
**Problem**: Multi-service Docker setups are brittle. Failures in service startup order, networking, or health checks can block all development. The existing mitigations are good but can be hardened.

**Mitigation & Implementation**:
1.  **Harden Health Checks**: Use more resilient health check commands and add `start_period` to give services time to initialize before the first check.
    *   **Action**: Update `docker/docker-compose.yml` health checks:
        ```yaml
        # postgres service
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-antone}"]
          interval: 10s
          timeout: 5s
          retries: 5
          start_period: 15s # Give Postgres time to initialize

        # backend-api service
        healthcheck:
          # Use wget (pre-installed on alpine) instead of curl
          test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3001/health"]
          interval: 20s
          timeout: 10s
          retries: 3
          start_period: 30s # Give Node.js app time to build and start
        ```
2.  **Ensure Correct App Binding**: Node.js applications in Docker often mistakenly bind to `127.0.0.1`, making them unreachable from other containers or the health check.
    *   **Action**: The backend server **MUST** bind to `0.0.0.0`. Add this snippet to the story's implementation requirements for the Hono server:
        ```typescript
        // backend/src/server.ts (or index.ts)
        serve({
          fetch: app.fetch,
          hostname: '0.0.0.0', // CRITICAL: Must be 0.0.0.0 to be reachable in Docker
          port: 3001,
        });
        ```

### **HIGH RISK: Monorepo Dockerfile Build Failures (TECH-001)**
**Problem**: Building a `pnpm` monorepo inside Docker is notoriously difficult. The build context, workspace dependencies, and `pnpm-lock.yaml` must be handled perfectly.

**Mitigation & Implementation**:
1.  **Create a Production-Grade, Optimized `Dockerfile`**: The `Dockerfile` must correctly copy all necessary `package.json` files, the lockfile, and source code in the right order to leverage layer caching and ensure `pnpm` can resolve the workspace.
    *   **Action**: Replace the existing `backend/Dockerfile` plan with this hardened version. This is the **correct** way to build a pnpm monorepo in Docker.
        ```dockerfile
        # backend/Dockerfile
        # --- Base Stage ---
        FROM node:24-alpine AS base
        WORKDIR /app
        RUN corepack enable && corepack prepare pnpm@10.0.0 --activate

        # --- Dependencies Stage ---
        FROM base AS deps
        # Copy ALL package.json files from the workspace
        COPY package.json pnpm-lock.yaml ./
        COPY backend/package.json ./backend/
        COPY shared/package.json ./shared/
        COPY database/package.json ./database/
        # Install ALL dependencies. Using --frozen-lockfile is a best practice.
        RUN pnpm install --frozen-lockfile --prod

        # --- Build Stage ---
        FROM base AS builder
        # Copy source code and dependencies
        COPY --from=deps /app/node_modules ./node_modules
        COPY --from=deps /app/backend/node_modules ./backend/node_modules
        COPY . .
        # Build the specific workspace package
        RUN pnpm --filter backend build

        # --- Production Stage ---
        FROM base AS production
        ENV NODE_ENV=production
        WORKDIR /app
        # Create a non-root user for security
        RUN addgroup --system --gid 1001 nodejs && adduser --system --uid 1001 antone
        # Copy only production artifacts
        COPY --from=deps /app/node_modules ./node_modules
        COPY --from=deps /app/backend/node_modules ./backend/node_modules
        COPY --from=builder /app/backend/dist ./backend/dist
        COPY --from=builder /app/backend/package.json ./backend/package.json
        USER antone
        EXPOSE 3001
        CMD ["node", "backend/dist/index.js"]
        ```

### **HIGH RISK: Leaking Secrets into Docker Image Layers (SEC-001)**
**Problem**: Using `ARG` or copying `.env` files into a Docker image can permanently bake secrets into an image layer, which is a major security vulnerability.

**Mitigation & Implementation**:
1.  **Use `.dockerignore` Religiously**: Explicitly ignore all secret files, environment files, and local development artifacts.
    *   **Action**: Create/update `.dockerignore` in the project root:
        ```
        # .dockerignore
        .env
        .env.*
        !.env.example

        node_modules
        dist
        .next
        coverage
        
        .DS_Store
        *.log
        
        .git
        .vscode
        ```
2.  **Use Runtime Environment Variables**: Secrets must only be passed to the container at runtime, not build time.
    *   **Action**: The `docker-compose.yml` file must use the `env_file` or `environment` properties to inject secrets.
        ```yaml
        # docker-compose.yml
        services:
          backend-api:
            env_file:
              - .env # Injects secrets at runtime
        ```

### **HIGH RISK: Inefficient Docker Layer Caching (PERF-001)**
**Problem**: A poorly structured `Dockerfile` will bust the layer cache on every code change, making builds painfully slow and discouraging developers from using Docker for local dev.

**Mitigation & Implementation**:
1.  **Structure Dockerfile for Caching**: The order of `COPY` and `RUN` commands is critical. Install dependencies *before* copying source code.
    *   **Action**: The provided production-grade `Dockerfile` (under TECH-001) is already structured for optimal caching. The key is that `COPY . .` (which copies source code) happens *after* `pnpm install`. A change to a single source file will not cause a full dependency re-install.
    *   **Action**: The architect must ensure the final `Dockerfile` in the story follows this pattern.

---
## 4. Final Recommendation

The story is **NO-GO**. The architect must integrate all the detailed `Mitigation & Implementation` plans above into the story's `Dev Notes` and `Tasks / Subtasks` sections to address the critical risks associated with Docker infrastructure. Once updated, the story will be ready for re-assessment.