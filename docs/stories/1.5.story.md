# Story 1.5: Reddit API Authentication

## Status: Draft

## Story

**As** the system,  
**I want** to authenticate with Reddit API using OAuth 2.0,  
**so that** I can monitor subreddits and post comments on behalf of u/antone_vita account.

## Acceptance Criteria

1. Reddit Developer account created and script app registered
2. OAuth credentials (Client ID, Client Secret, Refresh Token) stored in `.env` file (development) or Docker secrets (production)
3. `snoowrap` SDK installed and configured
4. Authentication module created at `@backend/platforms/reddit/auth`
5. API client initialized with user agent and proper credentials
6. Test endpoint `/api/reddit/verify` successfully fetches u/antone_vita profile
7. Subreddit access tested (e.g., r/hangover read permission)
8. **Rate limiting implemented and logged**:
   - Token bucket algorithm: 60 requests/min
   - Rate limiter class: `@backend/utils/rate-limiter.ts` (reuse from Story 1.4)
   - Integration: All API calls go through `rateLimiter.acquire('default')`
   - Monitoring: Rate limit headers from Reddit API logged
   - Handling: Exceeded limit triggers exponential backoff (1min base delay)
9. **Circuit breaker pattern** implemented (same as Twitter):
   - Threshold: 5 consecutive failures → circuit opens
   - Timeout: 30 seconds, fail-fast when OPEN
   - Class: `@backend/utils/circuit-breaker.ts` (reuse from Story 1.4)

---

## Tasks / Subtasks

- [ ] **Task 1: Create Reddit Rate Limiter Instance** (OPS-001 Mitigation)
  - [ ] Create `redditRateLimiter` singleton in rate-limiter.ts
  - [ ] Configure 60 requests/minute for reads
  - [ ] Configure 30 requests/minute for writes  
  - [ ] Verify using non-blocking `bottleneck` from Story 1.4
  - [ ] Export singleton instance

- [ ] **Task 2: Create Reddit Auth Module with Validation** (SEC-001 Mitigation)
  - [ ] Create `backend/src/platforms/reddit/auth.ts`
  - [ ] Implement `validateRedditCredentials()` function
  - [ ] Load credentials from environment (or secret manager)
  - [ ] Validate all required credentials present and formatted correctly
  - [ ] **SECURITY**: Never log actual credentials, only masked versions
  - [ ] Export `redditCredentials` object

- [ ] **Task 3: Add Reddit Secret Detection Rules** (SEC-001 Mitigation)
  - [ ] Update `.gitleaks.toml` with Reddit patterns
  - [ ] Add rules for refresh tokens, client IDs, client secrets
  - [ ] Test with fake credentials to verify detection

- [ ] **Task 4: Create Subreddit Configuration System** (BUS-001 Mitigation)
  - [ ] Create `backend/src/platforms/reddit/subreddit-config.ts`
  - [ ] Define `SubredditConfig` interface
  - [ ] Create `APPROVED_SUBREDDITS` allowlist
  - [ ] Implement `isSubredditApproved()` function
  - [ ] Implement `validateSubreddits()` function
  - [ ] Add manual approval tracking (reviewer, date)
  - [ ] Export validation functions

- [ ] **Task 5: Create Reddit Client Class** (AC: 3, 5, 8, 9 - ALL RISKS)
  - [ ] Create `backend/src/platforms/reddit/client.ts`
  - [ ] Use singleton `redditRateLimiter` from Task 1
  - [ ] Integrate CircuitBreaker from Story 1.4
  - [ ] **TECH-001 FIX**: Implement `searchSubreddits()` with multi-subreddit join (single API call)
  - [ ] **BUS-001 FIX**: Add subreddit validation in `searchSubreddits()`
  - [ ] **OPS-001 FIX**: Use `scheduleRead()`/`scheduleWrite()` (non-blocking)
  - [ ] Implement `comment()` method with non-blocking rate limiter
  - [ ] Implement `getKarma()` method with non-blocking rate limiter
  - [ ] Implement `verifyCredentials()` method
  - [ ] **TECH-002 FIX**: Implement `handleAuthError()` for token expiration
  - [ ] Implement `getRateLimitStatus()` for monitoring
  - [ ] Verify NO usage of `acquire()` method (use schedule methods only)

- [ ] **Task 6: Create Verification and Monitoring Endpoints** (AC: 6, 7)
  - [ ] Create `backend/src/api/routes/reddit.ts`
  - [ ] Implement `GET /api/reddit/verify` endpoint
  - [ ] Implement `GET /api/reddit/rate-limit-status` endpoint
  - [ ] Return profile info, karma score, rate limiter status
  - [ ] Test subreddit access permissions
  - [ ] Log rate limit information

- [ ] **Task 7: Add to Router** (AC: 6)
  - [ ] Register reddit routes in main Hono app
  - [ ] Add authentication middleware (optional for verify)

- [ ] **Task 8: Update Environment Template** (AC: 2, SEC-001)
  - [ ] Add Reddit credentials to `.env.example` with placeholders
  - [ ] Add comprehensive documentation comments
  - [ ] Document OAuth flow for obtaining refresh token
  - [ ] Document credential rotation procedure
  - [ ] Add REDDIT_ENABLED flag for disabling on auth failure

- [ ] **Task 9: Write Comprehensive Tests** (ALL RISKS)
  - [ ] Test Reddit client with mocked Snoowrap
  - [ ] Test multi-subreddit search (verify single API call) - TECH-001
  - [ ] Test subreddit validation (approved vs. unapproved) - BUS-001
  - [ ] Test non-blocking rate limiter behavior - OPS-001
  - [ ] Test authentication error handling - TECH-002
  - [ ] Test karma retrieval
  - [ ] Verify NO blocking `acquire()` calls in codebase

- [ ] **Task 10: Performance Verification** (TECH-001 Validation)
  - [ ] Measure API calls for searching 10 subreddits
  - [ ] Verify only 1 API call is made (not 10)
  - [ ] Document 10x performance improvement
  - [ ] Test with Reddit API rate limit monitoring

---

## Dev Notes

### Previous Story Insights
- Story 1.4 must be complete (provides FIXED RateLimiter and CircuitBreaker utilities)
- **CRITICAL**: Story 1.4's RateLimiter has been completely redesigned to use `bottleneck` (non-blocking). This story MUST use the new design.
- Reuse the same utility classes from 1.4

### Risk Mitigation Strategies
[Source: QA Risk Assessment 1.5-risk-20251202.md - Enhanced]

**CRITICAL: Story 1.5 has 1 CRITICAL and 3 HIGH-PRIORITY risks. The original story design has TWO critical flaws that must be fixed.**

**Risk Summary**:
- **CRITICAL (Score 9)**: 1 risk
  - SEC-001: Leaked Reddit Refresh Token via Git Commit
- **HIGH (Score 6)**: 3 risks
  - TECH-001: 10x API Over-use due to Inefficient Search Loop
  - OPS-001: Server Hang due to Reusing Flawed Rate Limiter
  - BUS-001: Account Ban due to Violating Subreddit Rules
- **MEDIUM (Score 3)**: 1 risk
  - TECH-002: Service Outage on Refresh Token Expiration

---

#### CRITICAL RISK: Credential Leakage (SEC-001) - **RELATED TO PRIMARY DIRECTIVE #1**
**Score: 9 (Critical)** - Leaked Reddit refresh token provides permanent account access to attacker.

**Mitigation**: This is addressed by Story 1.3's secret management (Doppler/Vault). Add Reddit-specific protections similar to Story 1.4:

```typescript
// backend/src/platforms/reddit/auth.ts

import { logger } from '../../utils/logger';

interface RedditCredentials {
  clientId: string;
  clientSecret: string;
  refreshToken: string;
}

function validateRedditCredentials(): RedditCredentials {
  const credentials = {
    clientId: process.env.REDDIT_CLIENT_ID,
    clientSecret: process.env.REDDIT_CLIENT_SECRET,
    refreshToken: process.env.REDDIT_REFRESH_TOKEN,
  };

  const missing = Object.entries(credentials)
    .filter(([_, value]) => !value)
    .map(([key]) => key);

  if (missing.length > 0) {
    throw new Error(`Missing Reddit credentials: ${missing.join(', ')}`);
  }

  // Validate format
  if (!credentials.refreshToken.startsWith('refresh_token=')) {
    logger.warn('REDDIT_REFRESH_TOKEN may have incorrect format');
  }

  // SECURITY: Never log actual credentials
  logger.info('Reddit credentials validated', {
    clientId: `${credentials.clientId.substring(0, 4)}...`,
    refreshToken: `${credentials.refreshToken.substring(0, 10)}...`,
  });

  return credentials as RedditCredentials;
}

export const redditCredentials = validateRedditCredentials();
```

**Add to `.gitleaks.toml`**:
```toml
[[rules]]
id = "reddit-refresh-token"
description = "Reddit Refresh Token"
# Catches the long, URL-safe base64 string characteristic of refresh tokens
regex = '''[a-zA-Z0-9_-]{20,}_[a-zA-Z0-9_-]{20,}'''
tags = ["key", "reddit", "token"]
# Keywords to reduce false positives
keywords = ["refreshToken", "reddit"]
```

#### HIGH RISK: Reusing Flawed Rate Limiter (OPS-001) - **RELATED TO PRIMARY DIRECTIVE #2**
**Score: 6 (High)** - The original story intended to reuse the broken RateLimiter from 1.4.

**Mitigation**: Story 1.4's RateLimiter has been **COMPLETELY REDESIGNED** using `bottleneck`. This story MUST use the new non-blocking design.

**UPDATED: Use Production-Grade RateLimiter**:
```typescript
// backend/src/utils/rate-limiter.ts (from Story 1.4 - already fixed)
// This story creates a Reddit-specific instance

import { RateLimiter } from './rate-limiter';

// Reddit-specific rate limiter instance
export const redditRateLimiter = new RateLimiter({
  read: {
    maxRequests: 60,      // Reddit: 60 requests/minute
    windowMs: 60 * 1000,  // 1 minute
  },
  write: {
    maxRequests: 30,      // Conservative write limit
    windowMs: 60 * 1000,
  },
});
```

#### HIGH RISK: Inefficient Subreddit Searching (TECH-001) - **CRITICAL PERFORMANCE FLAW**
**Score: 6 (High)** - The original `searchSubreddits()` makes ONE REQUEST PER SUBREDDIT. This is inefficient and will cause rapid rate limit exhaustion.

**Problem**: Original implementation (FLAWED):
```typescript
// FLAWED DESIGN - DO NOT IMPLEMENT
for (const sub of subreddits) {
  const posts = await this.client.getSubreddit(sub).search(...);
  results.push(...posts);
}
// This makes N requests for N subreddits! ❌
```

**Solution**: Reddit API supports searching multiple subreddits in ONE REQUEST by joining with `+`:
```typescript
// CORRECT DESIGN - IMPLEMENT THIS
async searchSubreddits(subreddits: string[], query: string): Promise<Submission[]> {
  // Join subreddits with + for single API call
  const subredditQuery = subreddits.join('+');  // e.g., "hangover+nutrition+fitness"
  
  return redditRateLimiter.scheduleRead(async () => {
    return this.circuitBreaker.execute(async () => {
      logger.info('Searching Reddit', { subreddits, query });
      
      // SINGLE API CALL for all subreddits
      const posts = await this.client
        .getSubreddit(subredditQuery)  // Searches ALL subreddits at once
        .search({
          query,
          time: 'day',
          sort: 'new',
          limit: 100,  // Max results per request
        });
      
      logger.info('Reddit search completed', {
        subreddits,
        resultsCount: posts.length,
      });
      
      return posts;
    });
  });
}
```

**Performance Impact**:
- Old design: 10 subreddits = 10 API calls
- New design: 10 subreddits = 1 API call
- **10x reduction in API usage**

#### HIGH RISK: Subreddit-Specific Rules (BUS-001)
**Score: 6 (High)** - Bot behavior may violate subreddit rules, leading to bans.

**Mitigation**: Implement per-subreddit configuration with manual approval:

```typescript
// backend/src/platforms/reddit/subreddit-config.ts

interface SubredditConfig {
  name: string;
  enabled: boolean;
  rulesReviewed: boolean;
  reviewedBy: string;
  reviewedAt: Date;
  allowComments: boolean;
  customRules: string[];
  bannedUntil?: Date;
}

// Subreddit allowlist (must be manually approved before activation)
const APPROVED_SUBREDDITS: Record<string, SubredditConfig> = {
  'hangover': {
    name: 'hangover',
    enabled: true,
    rulesReviewed: true,
    reviewedBy: 'winston',
    reviewedAt: new Date('2024-12-02'),
    allowComments: true,
    customRules: [
      'No medical claims',
      'Always include "NAD" (Not A Doctor) disclaimer',
      'Engage only with recovery/prevention questions',
    ],
  },
  // All other subreddits disabled by default
};

export function isSubredditApproved(subreddit: string): boolean {
  const config = APPROVED_SUBREDDITS[subreddit.toLowerCase()];
  
  if (!config) {
    logger.warn(`Subreddit not in approved list: ${subreddit}`);
    return false;
  }
  
  if (!config.enabled || !config.rulesReviewed) {
    logger.warn(`Subreddit not approved: ${subreddit}`, { config });
    return false;
  }
  
  if (config.bannedUntil && new Date() < config.bannedUntil) {
    logger.warn(`Subreddit temporarily banned: ${subreddit}`, {
      bannedUntil: config.bannedUntil,
    });
    return false;
  }
  
  return true;
}

export function validateSubreddits(subreddits: string[]): string[] {
  return subreddits.filter(sub => {
    const approved = isSubredditApproved(sub);
    if (!approved) {
      logger.error(`BLOCKED: Attempt to use unapproved subreddit: ${sub}`);
    }
    return approved;
  });
}
```

**Updated searchSubreddits() with validation**:
```typescript
async searchSubreddits(subreddits: string[], query: string): Promise<Submission[]> {
  // SECURITY: Only search approved subreddits
  const approvedSubreddits = validateSubreddits(subreddits);
  
  if (approvedSubreddits.length === 0) {
    logger.error('No approved subreddits to search', { requested: subreddits });
    return [];
  }
  
  if (approvedSubreddits.length < subreddits.length) {
    logger.warn('Some subreddits filtered out', {
      requested: subreddits,
      approved: approvedSubreddits,
    });
  }
  
  const subredditQuery = approvedSubreddits.join('+');
  
  return redditRateLimiter.scheduleRead(async () => {
    return this.circuitBreaker.execute(async () => {
      const posts = await this.client
        .getSubreddit(subredditQuery)
        .search({ query, time: 'day', sort: 'new', limit: 100 });
      return posts;
    });
  });
}
```

#### LOW RISK: Unhandled Token Expiration (TECH-002)
**Score: 3 (Low)** - Refresh tokens can expire or be revoked.

**Mitigation**: Add global error handler:
```typescript
// backend/src/platforms/reddit/client.ts

private handleAuthError(error: any): never {
  if (error.message?.includes('invalid_grant') || error.statusCode === 401) {
    logger.error('CRITICAL: Reddit refresh token invalid or expired', { error });
    
    // Disable all Reddit operations
    process.env.REDDIT_ENABLED = 'false';
    
    // TODO: Send alert (Story 1.8)
    // alerting.sendCritical('Reddit authentication failed - manual re-auth required');
    
    throw new Error('Reddit authentication failed - service disabled. Manual re-authentication required.');
  }
  throw error;
}

// Wrap all Reddit API calls
async searchSubreddits(subreddits: string[], query: string): Promise<Submission[]> {
  try {
    // ... existing implementation ...
  } catch (error) {
    this.handleAuthError(error);
  }
}
```

### Reddit Client Implementation - CORRECTED DESIGN
[Source: Risk Mitigation Strategies - Fixed for TECH-001 and OPS-001]

**⚠️ CRITICAL: The original implementation has been REPLACED to fix two critical flaws:**
1. **TECH-001**: Changed from loop (N requests) to single multi-subreddit search (1 request)
2. **OPS-001**: Changed from blocking `acquire()` to non-blocking `scheduleRead()`/`scheduleWrite()`

```typescript
// backend/src/platforms/reddit/client.ts

import Snoowrap from 'snoowrap';
import { redditRateLimiter } from '../../utils/rate-limiter';
import { CircuitBreaker } from '../../utils/circuit-breaker';
import { logger } from '../../utils/logger';
import { redditCredentials } from './auth';
import { validateSubreddits } from './subreddit-config';

export class RedditClient {
  private client: Snoowrap;
  private circuitBreaker: CircuitBreaker;

  constructor() {
    this.client = new Snoowrap({
      userAgent: 'Antone/1.0.0 (by /u/antone_vita)',
      clientId: redditCredentials.clientId,
      clientSecret: redditCredentials.clientSecret,
      refreshToken: redditCredentials.refreshToken,
    });

    this.circuitBreaker = new CircuitBreaker({
      threshold: 5,
      timeout: 30000,
    });
  }

  /**
   * Search multiple subreddits efficiently (FIXED TECH-001)
   * Uses single API call by joining subreddits with +
   */
  async searchSubreddits(subreddits: string[], query: string): Promise<Submission[]> {
    try {
      // SECURITY: Validate subreddits against approved list (BUS-001)
      const approvedSubreddits = validateSubreddits(subreddits);
      
      if (approvedSubreddits.length === 0) {
        logger.error('No approved subreddits to search', { requested: subreddits });
        return [];
      }
      
      // PERFORMANCE FIX: Join subreddits for single API call
      const subredditQuery = approvedSubreddits.join('+');
      
      // NON-BLOCKING: scheduleRead queues if limit reached (OPS-001 FIX)
      return await redditRateLimiter.scheduleRead(async () => {
        return this.circuitBreaker.execute(async () => {
          logger.info('Searching Reddit', {
            subreddits: approvedSubreddits,
            query,
          });
          
          const posts = await this.client
            .getSubreddit(subredditQuery)  // Single API call for ALL subreddits
            .search({
              query,
              time: 'day',
              sort: 'new',
              limit: 100,
            });
          
          logger.info('Reddit search completed', {
            subreddits: approvedSubreddits,
            resultsCount: posts.length,
          });
          
          return posts;
        });
      });
    } catch (error) {
      return this.handleAuthError(error);
    }
  }

  /**
   * Post a comment on a submission
   */
  async comment(submissionId: string, content: string): Promise<string> {
    try {
      // NON-BLOCKING: scheduleWrite queues if limit reached
      return await redditRateLimiter.scheduleWrite(async () => {
    return this.circuitBreaker.execute(async () => {
      const submission = await this.client.getSubmission(submissionId);
      const comment = await submission.reply(content);
          
          logger.info('Reddit comment posted', {
            submissionId,
            commentId: comment.id,
          });
          
      return comment.id;
    });
      });
    } catch (error) {
      return this.handleAuthError(error);
    }
  }

  /**
   * Get current user's karma for monitoring
   */
  async getKarma(): Promise<number> {
    try {
      // NON-BLOCKING: Use scheduleRead
      return await redditRateLimiter.scheduleRead(async () => {
    return this.circuitBreaker.execute(async () => {
      const me = await this.client.getMe();
      return me.comment_karma + me.link_karma;
    });
      });
    } catch (error) {
      return this.handleAuthError(error);
    }
  }

  /**
   * Verify Reddit credentials are valid
   */
  async verifyCredentials(): Promise<{ valid: boolean; karma: number; username: string }> {
    try {
      const me = await this.client.getMe();
      logger.info('Reddit credentials verified', {
        username: me.name,
        karma: me.comment_karma + me.link_karma,
      });
      return {
        valid: true,
        karma: me.comment_karma + me.link_karma,
        username: me.name,
      };
    } catch (error) {
      logger.error('Reddit credential verification failed', { error });
      return { valid: false, karma: 0, username: '' };
    }
  }

  /**
   * Handle authentication errors (TECH-002 mitigation)
   * Disables Reddit operations if refresh token is invalid
   */
  private handleAuthError(error: any): never {
    if (error.message?.includes('invalid_grant') || error.statusCode === 401) {
      logger.error('CRITICAL: Reddit refresh token invalid or expired', { error });
      
      // Disable all Reddit operations
      process.env.REDDIT_ENABLED = 'false';
      
      throw new Error('Reddit authentication failed - service disabled. Manual re-authentication required.');
    }
    throw error;
  }

  /**
   * Get rate limiter status for monitoring
   */
  getRateLimitStatus() {
    return redditRateLimiter.getStatus();
  }
}
```

### Reddit Auth Module
```typescript
// backend/src/platforms/reddit/auth.ts

import Snoowrap from 'snoowrap';
import { logger } from '../../utils/logger';

export function createRedditClient(): Snoowrap {
  const requiredEnvVars = [
    'REDDIT_CLIENT_ID',
    'REDDIT_CLIENT_SECRET',
    'REDDIT_REFRESH_TOKEN',
  ];

  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }

  logger.info('Initializing Reddit client');

  return new Snoowrap({
    userAgent: 'Antone/1.0.0 (by /u/antone_vita)',
    clientId: process.env.REDDIT_CLIENT_ID!,
    clientSecret: process.env.REDDIT_CLIENT_SECRET!,
    refreshToken: process.env.REDDIT_REFRESH_TOKEN!,
  });
}
```

### Environment Variables
```bash
# Reddit API Credentials
REDDIT_CLIENT_ID=your_client_id
REDDIT_CLIENT_SECRET=your_client_secret
REDDIT_REFRESH_TOKEN=your_refresh_token
```

### How to Obtain Reddit Credentials
1. Go to https://www.reddit.com/prefs/apps
2. Click "create another app..."
3. Select "script" type
4. Set redirect URI to http://localhost:8080
5. Copy Client ID (under app name) and Client Secret
6. Use OAuth flow to obtain refresh token

### File Structure
```
backend/src/
├── platforms/
│   ├── twitter/
│   │   ├── auth.ts
│   │   └── client.ts
│   └── reddit/
│       ├── auth.ts              # Authentication module
│       └── client.ts            # RedditClient class
└── api/
    └── routes/
        ├── twitter.ts
        └── reddit.ts            # Reddit verification endpoint
```

### Error Handling
[Source: architecture.md#9.2-integration-failure-matrix]

| Error | Detection | Handling |
|-------|-----------|----------|
| Rate limit exceeded | HTTP 429 | Queue with exponential backoff (1min base) |
| Comment removed by mod | Post success, later 404 | Log removal, update safety KPIs |
| Subreddit banned | 403 response | Remove from monitoring list |
| Authentication failed | 401 response | Alert critical, refresh token |

---

## Testing

### Test File Location
- `backend/tests/unit/platforms/reddit/client.test.ts`
- `backend/tests/integration/api/reddit.test.ts`

### Testing Standards
- Mock Snoowrap responses
- Test rate limiter with Reddit timing
- Test karma retrieval
- Test subreddit search pagination

### Story-Specific Testing Requirements
1. Verify credentials returns username and karma
2. Subreddit search returns submissions
3. Rate limiter enforces 60 req/min
4. Circuit breaker works with Reddit client
5. `/api/reddit/verify` returns correct data

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |
| 2024-12-02 | 2.0 | **CRITICAL REDESIGN**: Fixed multiple critical flaws. **TECH-001** (10x performance improvement): Replaced inefficient loop with single multi-subreddit API call (subreddits.join('+')).  **OPS-001**: Updated to use non-blocking rate limiter from Story 1.4 (scheduleRead/scheduleWrite). **SEC-001**: Added credential validation and secret scanning. **BUS-001**: Added subreddit approval system with manual review tracking. **TECH-002**: Added token expiration handling. Completely rewrote Reddit Client implementation. Updated all tasks to reflect fixes. | Winston (Architect) |
| 2024-12-02 | 2.1 | **COMPREHENSIVE QA-DRIVEN UPDATE**: Integrated complete enhanced risk assessment (5 risks: 1 CRITICAL, 3 HIGH, 1 MEDIUM). Enhanced `.gitleaks.toml` regex pattern for Reddit refresh tokens with false-positive reduction. Added comprehensive risk summary section. Verified all QA mitigations integrated into Dev Notes. Status: **NO-GO until all Critical/High mitigations implemented**. | Winston (Architect) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

