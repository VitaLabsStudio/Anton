# Story 2.2: Signal 2 - Author Context Engine

## Status: Draft

## Story

**As a** the decision engine,  
**I want** to retrieve and score author relationship history from database,  
**so that** I can calculate an Author Relationship Score (ARS) reflecting past positive/negative interactions.

## Acceptance Criteria

1. Module created at `@backend/analysis/signal-2-author.ts`
2. Function queries `authors` table by platform + handle
3. Archetypes from bio/history parsed (e.g., "healthcare", "comedian", "parent")
4. Positive signals weighted: prior thanks (+0.15), link click (+0.10), purchase (+0.25)
5. Negative signals weighted: block (-0.30), report (-0.40), hostile reply (-0.20)
6. Base ARS for unknown authors: 0.50 (neutral)
7. Function returns ARS score between 0.0-1.0
8. Unit tests validate scoring logic with mock author data
9. New authors created in `authors` table if not exists

---

## Tasks / Subtasks

- [ ] **Task 1: Create Author Context Module** (AC: 1, 2, 6, 7)
  - [ ] Create `backend/src/analysis/signal-2-author.ts`
  - [ ] Implement `analyzeAuthorContext(author: Author)` function
  - [ ] Query authors table by platform + handle
  - [ ] Return base score 0.50 for unknown authors
  - [ ] Return SignalResult with ARS score

- [ ] **Task 2: Implement Interaction History Scoring** (AC: 4, 5)
  - [ ] Parse `interaction_history` JSON field
  - [ ] Apply positive signal weights: thanks (+0.15), click (+0.10), purchase (+0.25)
  - [ ] Apply negative signal weights: block (-0.30), report (-0.40), hostile (-0.20)
  - [ ] Calculate cumulative score adjustment
  - [ ] Cap final score between 0.0-1.0

- [ ] **Task 3: Implement Archetype Detection** (AC: 3)
  - [ ] Parse author bio for keywords
  - [ ] Detect healthcare professional: "nurse", "doctor", "pharmacist"
  - [ ] Detect comedian: "comedian", "comic", "funny"
  - [ ] Detect parent: "mom", "dad", "parent"
  - [ ] Store detected archetypes in `archetype_tags` array
  - [ ] Use archetypes for context in decision

- [ ] **Task 4: Implement Author Creation** (AC: 9)
  - [ ] Check if author exists by platform + platform_id
  - [ ] If not exists, create new author record
  - [ ] Set initial relationship_score to 0.50
  - [ ] Set interaction_history to empty array
  - [ ] Return newly created author

- [ ] **Task 5: Write Unit Tests** (AC: 8)
  - [ ] Test base score for unknown authors
  - [ ] Test positive interactions increase score
  - [ ] Test negative interactions decrease score
  - [ ] Test score capping (0.0-1.0)
  - [ ] Test author creation

---

## Dev Notes

### Previous Story Insights
- Story 1.3 complete (database schema with authors table)
- Story 2.1 complete (first signal analyzer pattern)

### Author Context Engine Implementation
[Source: architecture.md#7.2-core-domain-modules]

```typescript
// backend/src/analysis/signal-2-author.ts

import { prisma } from '../db';
import { Author, Platform } from '@prisma/client';
import { logger } from '../utils/logger';

interface SignalResult {
  score: number;
  confidence: number;
  archetypes: string[];
  interactionCount: number;
}

interface InteractionEvent {
  type: 'thanks' | 'click' | 'purchase' | 'block' | 'report' | 'hostile_reply';
  timestamp: string;
  context?: any;
}

const INTERACTION_WEIGHTS = {
  thanks: 0.15,
  click: 0.10,
  purchase: 0.25,
  block: -0.30,
  report: -0.40,
  hostile_reply: -0.20,
};

const BASE_SCORE = 0.50;

export class AuthorContextAnalyzer {
  async analyzeAuthorContext(
    platform: Platform,
    platformId: string,
    handle: string
  ): Promise<SignalResult> {
    try {
      // Try to find existing author
      let author = await prisma.author.findUnique({
        where: {
          platform_platformId: {
            platform,
            platformId,
          },
        },
      });

      // Create new author if not exists
      if (!author) {
        author = await this.createAuthor(platform, platformId, handle);
      }

      // Parse interaction history
      const interactions = this.parseInteractionHistory(author.interactionHistory);

      // Calculate relationship score
      const score = this.calculateRelationshipScore(interactions);

      // Detect archetypes
      const archetypes = this.detectArchetypes(author);

      return {
        score,
        confidence: interactions.length > 0 ? 0.9 : 0.5, // Higher confidence with history
        archetypes,
        interactionCount: interactions.length,
      };
    } catch (error) {
      logger.error('Author context analysis failed', { error, platform, platformId });
      // Return neutral score on error
      return {
        score: BASE_SCORE,
        confidence: 0.0,
        archetypes: [],
        interactionCount: 0,
      };
    }
  }

  private async createAuthor(
    platform: Platform,
    platformId: string,
    handle: string
  ): Promise<Author> {
    logger.info('Creating new author', { platform, platformId, handle });

    return prisma.author.create({
      data: {
        platform,
        platformId,
        handle,
        relationshipScore: BASE_SCORE,
        interactionHistory: [],
        firstSeenAt: new Date(),
        lastSeenAt: new Date(),
      },
    });
  }

  private parseInteractionHistory(history: any): InteractionEvent[] {
    if (!Array.isArray(history)) return [];
    return history as InteractionEvent[];
  }

  private calculateRelationshipScore(interactions: InteractionEvent[]): number {
    let score = BASE_SCORE;

    for (const interaction of interactions) {
      const weight = INTERACTION_WEIGHTS[interaction.type];
      if (weight) {
        score += weight;
      }
    }

    // Cap between 0.0 and 1.0
    return Math.max(0.0, Math.min(1.0, score));
  }

  private detectArchetypes(author: Author): string[] {
    const archetypes: string[] = [];
    const bio = author.displayName?.toLowerCase() || '';

    // Healthcare professional
    if (/(nurse|doctor|pharmacist|physician|md|rn)/i.test(bio)) {
      archetypes.push('healthcare_pro');
    }

    // Comedian
    if (/(comedian|comic|funny|humor)/i.test(bio)) {
      archetypes.push('comedian');
    }

    // Parent
    if (/(mom|dad|parent|mother|father)/i.test(bio)) {
      archetypes.push('parent');
    }

    // Store in database for future use
    if (archetypes.length > 0) {
      this.updateArchetypeTags(author.id, archetypes).catch(err =>
        logger.error('Failed to update archetype tags', { err })
      );
    }

    return archetypes;
  }

  private async updateArchetypeTags(authorId: string, tags: string[]): Promise<void> {
    await prisma.author.update({
      where: { id: authorId },
      data: { archetypeTags: tags },
    });
  }
}

// Export singleton
export const authorContextAnalyzer = new AuthorContextAnalyzer();
export const analyzeAuthorContext = (
  platform: Platform,
  platformId: string,
  handle: string
) => authorContextAnalyzer.analyzeAuthorContext(platform, platformId, handle);
```

### Interaction History Schema
[Source: architecture.md#5.2-prisma-schema]

The `authors` table includes:
```prisma
model Author {
  // ...
  relationshipScore Float @default(0.5) @map("relationship_score")
  interactionHistory Json @default("[]") @map("interaction_history")
  archetypeTags String[] @map("archetype_tags")
  // ...
}
```

### Interaction History JSON Format
```json
[
  {
    "type": "thanks",
    "timestamp": "2025-12-01T10:30:00Z",
    "context": {
      "replyId": "reply-123",
      "platform": "TWITTER"
    }
  },
  {
    "type": "click",
    "timestamp": "2025-12-01T10:35:00Z",
    "context": {
      "utmCode": "antone_reply123",
      "destination": "https://vita.com"
    }
  },
  {
    "type": "purchase",
    "timestamp": "2025-12-01T12:00:00Z",
    "context": {
      "orderId": "order-456",
      "amount": 29.99
    }
  }
]
```

### Scoring Logic
Starting from base 0.50:
- **Positive interactions** (increase score):
  - Thanks/positive reply: +0.15 → New score: 0.65
  - Link click: +0.10 → New score: 0.75
  - Purchase: +0.25 → New score: 1.00 (capped)

- **Negative interactions** (decrease score):
  - Hostile reply: -0.20 → New score: 0.30
  - Block: -0.30 → New score: 0.20
  - Report: -0.40 → New score: 0.10

### File Structure
```
backend/src/
└── analysis/
    ├── signal-1-linguistic.ts   # SSS analyzer
    └── signal-2-author.ts       # ARS analyzer
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/signal-2-author.test.ts`

### Testing Standards
- Mock Prisma client
- Test all interaction weights
- Verify score capping
- Test author creation

### Story-Specific Testing Requirements
1. Unknown authors return 0.50 base score
2. Positive interactions increase score correctly
3. Negative interactions decrease score correctly
4. Score stays within 0.0-1.0 range
5. Archetypes detected from bio
6. New authors created when not found

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

