# Story 3.4: Platform Posting Service - Twitter/X

## Status: Draft

## Story

**As a** the system,  
**I want** to post approved replies to Twitter/X using API v2,  
**so that** @antone_vita can engage with users on Twitter.

## Acceptance Criteria

1. Twitter posting service created at `@backend/platforms/twitter/poster.ts`
2. Function accepts reply ID and posts content as reply to original tweet
3. Rate limiting enforced (300 posts per 15 minutes)
4. Error handling for API failures (thread locked, user blocked us, tweet deleted)
5. Posted reply metadata captured: tweet_id, posted_at, initial_metrics
6. Reply status updated in database: `posted_at` timestamp, `platform_post_id`
7. Posting failures logged with reason and retried up to 2 times
8. Integration test (staging): Post test reply to controlled test tweet
9. Manual approval required before posting (approval workflow in Story 3.6)

---

## Tasks / Subtasks

- [ ] **Task 1: Create Twitter Poster Module** (AC: 1, 2)
  - [ ] Create `backend/src/platforms/twitter/poster.ts`
  - [ ] Implement postReply(replyId) function
  - [ ] Fetch reply from database
  - [ ] Fetch original post
  - [ ] Call Twitter API to post reply

- [ ] **Task 2: Implement Rate Limiting** (AC: 3)
  - [ ] Reuse RateLimiter from Story 1.4
  - [ ] Enforce 300 posts/15min
  - [ ] Queue if limit reached

- [ ] **Task 3: Implement Error Handling** (AC: 4, 7)
  - [ ] Handle thread locked (403)
  - [ ] Handle user blocked us (403)
  - [ ] Handle tweet deleted (404)
  - [ ] Retry transient errors (2 max)
  - [ ] Log all failures

- [ ] **Task 4: Capture Posted Metadata** (AC: 5, 6)
  - [ ] Get tweet_id from response
  - [ ] Update reply.platform_post_id
  - [ ] Set reply.posted_at timestamp
  - [ ] Store initial_metrics (0 likes)

- [ ] **Task 5: Create Posting API Endpoint** (AC: 9)
  - [ ] Create `backend/src/api/routes/posting.ts`
  - [ ] Implement POST /api/replies/:id/post
  - [ ] Require approval_status = APPROVED
  - [ ] Call Twitter poster service

- [ ] **Task 6: Write Integration Test** (AC: 8)
  - [ ] Use staging Twitter account
  - [ ] Post test reply
  - [ ] Verify tweet appears
  - [ ] Verify database updated

---

## Dev Notes

### Previous Story Insights
- Story 1.4 complete (TwitterClient, RateLimiter)
- Story 3.3 complete (replies generated)

### Twitter Poster Implementation
```typescript
// backend/src/platforms/twitter/poster.ts

import { TwitterClient } from './client';
import { prisma } from '../../db';
import { logger } from '../../utils/logger';

export class TwitterPoster {
  private client: TwitterClient;

  constructor() {
    this.client = new TwitterClient();
  }

  async postReply(replyId: string): Promise<{ success: boolean; tweetId?: string }> {
    try {
      // Get reply from database
      const reply = await prisma.reply.findUnique({
        where: { id: replyId },
        include: {
          decision: {
            include: { post: true },
          },
        },
      });

      if (!reply) {
        throw new Error(`Reply not found: ${replyId}`);
      }

      if (reply.approvalStatus !== 'APPROVED' && reply.approvalStatus !== 'AUTO_APPROVED') {
        throw new Error(`Reply not approved: ${replyId}`);
      }

      // Add UTM to link
      const contentWithLink = this.addUtmLink(reply.content, reply.utmCode);

      // Post to Twitter
      const tweetId = await this.client.reply(
        reply.decision.post.platformPostId,
        contentWithLink
      );

      // Update reply in database
      await prisma.reply.update({
        where: { id: replyId },
        data: {
          platformPostId: tweetId,
          postedAt: new Date(),
          metricsJson: { likes: 0, replies: 0, retweets: 0 },
        },
      });

      logger.info('Reply posted to Twitter', {
        replyId,
        tweetId,
        originalPostId: reply.decision.post.platformPostId,
      });

      return { success: true, tweetId };
    } catch (error: any) {
      logger.error('Failed to post Twitter reply', {
        error: error.message,
        replyId,
      });

      // Retry logic
      if (this.isRetryable(error)) {
        return this.retryPost(replyId, 1);
      }

      return { success: false };
    }
  }

  private async retryPost(replyId: string, attempt: number): Promise<any> {
    const maxRetries = 2;
    if (attempt > maxRetries) {
      return { success: false };
    }

    await this.sleep(Math.pow(2, attempt) * 1000); // Exponential backoff

    try {
      return await this.postReply(replyId);
    } catch (error) {
      return this.retryPost(replyId, attempt + 1);
    }
  }

  private isRetryable(error: any): boolean {
    // Network errors, 5xx errors are retryable
    return error.code === 'ECONNREFUSED' || 
           error.code === 'ETIMEDOUT' ||
           (error.status >= 500 && error.status < 600);
  }

  private addUtmLink(content: string, utmCode: string): string {
    const vitaLink = `https://vita.com?utm_source=antone&utm_content=${utmCode}`;
    return content.replace(/{{link}}/g, vitaLink);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Export singleton
export const twitterPoster = new TwitterPoster();
```

### File Structure
```
backend/src/
├── platforms/
│   └── twitter/
│       ├── client.ts
│       ├── auth.ts
│       ├── monitor.ts
│       └── poster.ts            # THIS STORY
└── api/
    └── routes/
        └── posting.ts           # Posting API
```

---

## Testing

### Test File Location
- `backend/tests/unit/platforms/twitter/poster.test.ts`
- `backend/tests/integration/platforms/twitter/posting.test.ts`

### Testing Standards
- Mock Twitter API
- Test retry logic
- Test error handling

### Story-Specific Testing Requirements
1. Approved reply posts successfully
2. Tweet ID saved to database
3. posted_at timestamp set
4. Rate limiting enforced
5. Errors handled gracefully
6. Retry logic works (max 2)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*







