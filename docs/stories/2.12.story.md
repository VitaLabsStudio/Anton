# Story 2.12: Competitive Intelligence Detector

## Status: Ready for Review

## Story

**As a** the decision engine,  
**I want** to detect mentions of competing products in posts and trigger defensive positioning strategies,  
**so that** Antone educates users about Vita's unique value proposition when competitors are discussed.

## Acceptance Criteria

1. Module created at `@backend/analysis/competitive-detector.ts`
2. **Competitor Product Library** seeded from `@backend/data/competitors.json` into `competitors` database table (database is source of truth):
   - Rehydration brands: LiquidIV, Drip Drop, Pedialyte, Gatorade, Nuun
   - Hangover pills: ZBiotics, Flyby, AfterDrink, Cheers, DHM Detox
   - IV therapy: The I.V. Doc, Revive, HydroMed
   - Home remedies tracked: "hair of the dog", activated charcoal, pickle juice
3. Competitor detection in post text using variation matching (handles spaces, hyphens, case)
   - If multiple competitors detected in one post, respond to highest opportunityScore only; log all detected competitors
4. **Competitive Context Analysis**:
   - Positive mention: "LiquidIV works great for me" → Soft positioning
   - Question: "Does Drip Drop actually work?" → Educational comparison
   - Negative mention: "ZBiotics didn't help" → Strong positioning opportunity
5. **Defensive Positioning Strategy**:
   - Tone: Polite, educational (never attack competitors)
   - Message template: "Those work via [mechanism]; Vita uses transdermal delivery which bypasses upset stomach"
   - Differentiation focus: Transdermal vs oral, convenience, science-backed
6. Competitive posts flagged in decision: `{competitor_detected: "LiquidIV", positioning_opportunity: "high"}`
7. Mode adjustment: Competitive posts trigger **Hybrid** or **Helpful** mode (never pure Engagement)
8. Preferred archetype: **Problem-Solution Direct** or **Credibility-anchor**
9. Rate limiting: Max 5 per competitor per day, max 15 total competitive replies per day (prioritize by opportunityScore when global cap reached)
10. API endpoints for competitive intelligence (GET /api/competitive/mentions) - dashboard integration deferred to future story
11. Unit tests validate competitor detection across 50+ mention variations
12. Market intelligence logged: Which competitors are most discussed? What complaints?

---

## Tasks / Subtasks

- [x] **Task 1: Create Competitors Configuration** (AC: 2)
  - [x] Create `backend/src/data/competitors.json`
  - [x] Add all rehydration brands
  - [x] Add all hangover pill brands
  - [x] Add IV therapy services
  - [x] Add home remedies
  - [x] Include brand keywords and variations

- [x] **Task 2: Seed Competitors Database** (AC: 2)
  - [x] Create seed script for competitors table
  - [x] Populate from competitors.json
  - [x] Include category, mechanism, price point
  - [x] Run seed on database initialization

- [x] **Task 3: Create Competitive Detector Module** (AC: 1, 3)
  - [x] Create `backend/src/analysis/competitive-detector.ts`
  - [x] Implement detectCompetitor(content) function
  - [x] Variation matching for brand names (spaces, hyphens, case)
  - [x] Handle multiple competitors in one post
  - [x] Return highest opportunityScore competitor
  - [x] Log all detected competitors
  - [x] Return competitor name and confidence

- [x] **Task 4: Implement Context Analysis** (AC: 4)
  - [x] Detect positive mentions (sentiment analysis)
  - [x] Detect questions about competitors
  - [x] Detect negative mentions (complaints)
  - [x] Return positioning opportunity score

- [x] **Task 5: Implement Mode Adjustment** (AC: 7)
  - [x] Competitive posts → HYBRID or HELPFUL
  - [x] Never use ENGAGEMENT for competitive posts
  - [x] Integrate with decision engine

- [x] **Task 6: Implement Archetype Preference** (AC: 8)
  - [x] Prefer PROBLEM_SOLUTION_DIRECT
  - [x] Or CREDIBILITY_ANCHOR
  - [x] Integrate with archetype selector

- [x] **Task 7: Implement Rate Limiting** (AC: 9)
  - [x] Track competitive replies per competitor per day
  - [x] Max 5 per competitor per day
  - [x] Max 15 total competitive replies per day (global)
  - [x] Prioritize by opportunityScore when global cap reached
  - [x] Store in Redis with daily reset

- [x] **Task 8: Create Market Intelligence Logging** (AC: 12)
  - [x] Log all competitor mentions
  - [x] Save to competitive_mentions table
  - [x] Track sentiment and satisfaction
  - [x] Track positioning opportunities

- [x] **Task 9: Create Dashboard API** (AC: 10)
  - [x] Endpoint GET /api/competitive/mentions
  - [x] Return competitor share of voice
  - [x] Return sentiment breakdown
  - [x] Return conversion opportunities

- [x] **Task 10: Write Unit Tests** (AC: 11)
  - [x] Test 50+ competitor mention variations
  - [x] Test variation matching (spaces, hyphens, case)
  - [x] Test multi-competitor handling (highest opportunityScore wins)
  - [x] Test sentiment detection
  - [x] Test per-competitor rate limiting (max 5/day)
  - [x] Test global rate limiting (max 15/day, prioritize by opportunityScore)

---

## Dev Notes

### Previous Story Insights
- Story 1.3 complete (competitors and competitive_mentions tables)
- Story 2.5 complete (decision engine integration)

### Decision Engine Integration

**WHERE**: Called in `backend/src/analysis/decision-engine.ts` during post analysis

**WHEN**: During the post analysis flow, after power-user detection but before mode selection

**HOW**: The competitive result adjusts mode selection and archetype preference

```typescript
// backend/src/analysis/decision-engine.ts

import { detectCompetitor, saveCompetitiveMention } from './competitive-detector';

export async function analyzePost(post: Post, author: Author): Promise<Decision> {
  // Step 1: Power user detection
  const powerUserScore = await detectPowerUser(author);
  
  // Step 2: Competitive detection
  const competitiveResult = await detectCompetitor(post.content);
  
  // Step 3: Save competitive mention if detected
  if (competitiveResult.detected) {
    await saveCompetitiveMention(post.id, competitiveResult);
  }
  
  // Step 4: Mode selection (competitive posts override default logic)
  let mode: Mode;
  if (competitiveResult.detected) {
    // Competitive posts NEVER use ENGAGEMENT mode
    mode = competitiveResult.opportunityScore > 0.6 ? 'HELPFUL' : 'HYBRID';
  } else {
    // Normal mode selection logic
    mode = selectMode(post, author, powerUserScore);
  }
  
  // Step 5: Archetype preference
  const archetypePreferences = competitiveResult.detected
    ? ['PROBLEM_SOLUTION_DIRECT', 'CREDIBILITY_ANCHOR'] // Competitive posts
    : getDefaultArchetypePreferences(mode); // Normal posts
  
  // Step 6: Rate limiting check
  const rateLimitOk = await checkCompetitiveRateLimit(
    competitiveResult.name,
    competitiveResult.opportunityScore
  );
  
  return {
    postId: post.id,
    mode,
    archetypePreferences,
    competitorDetected: competitiveResult.detected,
    competitorName: competitiveResult.name,
    opportunityScore: competitiveResult.opportunityScore,
    shouldReply: rateLimitOk,
    reason: competitiveResult.detected
      ? `Competitive post: ${competitiveResult.name} (${competitiveResult.satisfaction})`
      : 'Normal post analysis',
  };
}

async function checkCompetitiveRateLimit(
  competitorName: string | null,
  opportunityScore: number
): Promise<boolean> {
  if (!competitorName) return true;
  
  const today = new Date().toISOString().split('T')[0];
  
  // Check per-competitor limit (max 5/day)
  const competitorCount = await redis.get(`competitive:${competitorName}:${today}`);
  if (competitorCount && parseInt(competitorCount) >= 5) {
    return false;
  }
  
  // Check global limit (max 15/day total)
  const globalCount = await redis.get(`competitive:global:${today}`);
  if (globalCount && parseInt(globalCount) >= 15) {
    // Global cap reached - only allow if opportunityScore is high enough
    // Get lowest opportunity score currently in today's replies
    const lowestScore = await getLowestOpportunityScoreToday();
    return opportunityScore > lowestScore; // Replace lowest with this higher-priority one
  }
  
  return true;
}
```

### Competitive Detector Implementation
```typescript
// backend/src/analysis/competitive-detector.ts

import { prisma } from '../db';
import { logger } from '../utils/logger';
import competitors from '../data/competitors.json';

interface CompetitorResult {
  detected: boolean;
  name: string | null;
  category: string | null;
  sentiment: 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE';
  satisfaction: 'SATISFIED' | 'UNSATISFIED' | 'QUESTIONING';
  opportunityScore: number; // 0-1, higher = better opportunity
  confidence: number;
}

export async function detectCompetitor(content: string): Promise<CompetitorResult> {
  const lowerContent = content.toLowerCase();
  const detectedCompetitors: CompetitorResult[] = [];

  // Check each competitor
  for (const competitor of competitors.competitors) {
    for (const keyword of competitor.brandKeywords) {
      if (variationMatch(lowerContent, keyword.toLowerCase())) {
        // Competitor detected
        const sentiment = analyzeSentiment(content, keyword);
        const satisfaction = analyzeSatisfaction(content);
        const opportunity = calculateOpportunity(sentiment, satisfaction);

        const result: CompetitorResult = {
          detected: true,
          name: competitor.name,
          category: competitor.category,
          sentiment,
          satisfaction,
          opportunityScore: opportunity,
          confidence: 0.90,
        };

        detectedCompetitors.push(result);
        
        logger.info('Competitor detected', {
          competitor: competitor.name,
          category: competitor.category,
          sentiment,
          satisfaction,
          opportunity,
        });
        
        break; // Only match once per competitor
      }
    }
  }

  // If multiple competitors detected, return highest opportunityScore
  if (detectedCompetitors.length > 0) {
    // Log all detected competitors
    logger.info('Multiple competitors detected', {
      count: detectedCompetitors.length,
      competitors: detectedCompetitors.map(c => c.name),
    });
    
    // Return competitor with highest opportunity score
    return detectedCompetitors.reduce((highest, current) =>
      current.opportunityScore > highest.opportunityScore ? current : highest
    );
  }

  // No competitor detected
  return {
    detected: false,
    name: null,
    category: null,
    sentiment: 'NEUTRAL',
    satisfaction: 'SATISFIED',
    opportunityScore: 0,
    confidence: 1.0,
  };
}

function variationMatch(text: string, keyword: string): boolean {
  // Handle variations: "liquid iv", "liquidiv", "liquid-iv" (spaces, hyphens, case)
  const normalized = keyword.replace(/[\s-]/g, '');
  const pattern = new RegExp(normalized, 'i');
  const textNormalized = text.replace(/[\s-]/g, '');
  return pattern.test(textNormalized);
}

function analyzeSentiment(content: string, brand: string): 'POSITIVE' | 'NEUTRAL' | 'NEGATIVE' {
  // Positive indicators
  const positive = /(works?|great|love|amazing|best|helped|recommend)/i;
  if (positive.test(content)) {
    return 'POSITIVE';
  }

  // Negative indicators
  const negative = /(didn't work|useless|waste|scam|disappointed|failed)/i;
  if (negative.test(content)) {
    return 'NEGATIVE';
  }

  return 'NEUTRAL';
}

function analyzeSatisfaction(content: string): 'SATISFIED' | 'UNSATISFIED' | 'QUESTIONING' {
  // Questioning
  if (/\?/.test(content) && /(does|is|will|should|work)/i.test(content)) {
    return 'QUESTIONING';
  }

  // Unsatisfied
  if (/(didn't help|still feel|not working|waste of money)/i.test(content)) {
    return 'UNSATISFIED';
  }

  // Satisfied
  if (/(worked|helped|feel better|recommend)/i.test(content)) {
    return 'SATISFIED';
  }

  return 'QUESTIONING';
}

function calculateOpportunity(
  sentiment: string,
  satisfaction: string
): number {
  // Higher score = better positioning opportunity
  if (satisfaction === 'UNSATISFIED') return 0.9;
  if (satisfaction === 'QUESTIONING') return 0.7;
  if (sentiment === 'NEGATIVE') return 0.8;
  if (sentiment === 'NEUTRAL') return 0.5;
  if (sentiment === 'POSITIVE') return 0.3; // Soft positioning only
  return 0.5;
}

// Save competitive mention
export async function saveCompetitiveMention(
  postId: string,
  result: CompetitorResult
): Promise<void> {
  if (!result.detected) return;

  const competitor = await prisma.competitor.findFirst({
    where: { name: result.name! },
  });

  if (!competitor) {
    logger.warn('Competitor not in database', { name: result.name });
    return;
  }

  await prisma.competitiveMention.create({
    data: {
      postId,
      competitorId: competitor.id,
      sentiment: result.sentiment,
      satisfaction: result.satisfaction,
      opportunityScore: result.opportunityScore,
      replied: false,
    },
  });
}
```

### Competitors Configuration
```json
// backend/src/data/competitors.json
{
  "version": "1.0",
  "competitors": [
    {
      "name": "LiquidIV",
      "category": "REHYDRATION",
      "primaryMechanism": "Oral electrolyte drink mix",
      "pricePoint": "MID",
      "brandKeywords": ["liquid iv", "liquidiv", "liquid-iv"]
    },
    {
      "name": "Drip Drop",
      "category": "REHYDRATION",
      "primaryMechanism": "Medical-grade oral rehydration",
      "pricePoint": "MID",
      "brandKeywords": ["drip drop", "dripdrop", "drip-drop"]
    },
    {
      "name": "Pedialyte",
      "category": "REHYDRATION",
      "primaryMechanism": "Pediatric electrolyte solution",
      "pricePoint": "LOW",
      "brandKeywords": ["pedialyte"]
    },
    {
      "name": "ZBiotics",
      "category": "HANGOVER_PILLS",
      "primaryMechanism": "Probiotic enzyme pre-drinking",
      "pricePoint": "HIGH",
      "brandKeywords": ["zbiotics", "z-biotics"]
    },
    {
      "name": "Flyby",
      "category": "HANGOVER_PILLS",
      "primaryMechanism": "Vitamin/herb capsules",
      "pricePoint": "MID",
      "brandKeywords": ["flyby", "flyby hangover"]
    },
    {
      "name": "AfterDrink",
      "category": "HANGOVER_PILLS",
      "primaryMechanism": "DHM supplement",
      "pricePoint": "MID",
      "brandKeywords": ["afterdrink", "after drink"]
    }
  ]
}
```

### Defensive Positioning Template
[Source: epic-2]

```
Those work via [mechanism]; Vita uses transdermal delivery which bypasses your upset stomach and doesn't require water when you're nauseous. Worth checking out if oral solutions aren't helping.

—Antone (Vita) | Helped 1,247 people this month
https://vita.com?utm_source=antone&utm_content=reply_abc123
```

### File Structure
```
backend/src/
├── data/
│   └── competitors.json         # Competitor database
├── analysis/
│   └── competitive-detector.ts  # THIS STORY
└── api/
    └── routes/
        └── competitive.ts       # Competitive intelligence API
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/competitive-detector.test.ts`

### Testing Standards
- Test variation matching (spaces, hyphens, case)
- Test sentiment analysis
- Test opportunity scoring
- Test multi-competitor handling

### Story-Specific Testing Requirements
1. 50+ brand variations detected
2. Variation matching handles spaces, hyphens, case
3. Multiple competitors in one post: highest opportunityScore returned
4. All detected competitors logged
5. Sentiment classified correctly
6. Satisfaction classified correctly
7. Opportunity score calculated correctly
8. Rate limiting: per-competitor limit (max 5/day)
9. Rate limiting: global limit (max 15/day, prioritize by opportunityScore)
10. Competitive mentions saved to database

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |
| 2024-12-05 | 1.1 | Updated per Quinn's QA review: Added decision-engine integration details, global rate limiting, multi-competitor handling, variation matching accuracy | Bob (SM Agent) |

---

## Dev Agent Record
- **Agent Name:** James
- **Date:** 2025-12-11
- **Status:** Ready for Review
- **Notes:** Implemented competitive detector, integration with decision engine, rate limiting, and dashboard API. Added strict unit tests including segmentation logic for multi-competitor sentiment isolation.
- **File List:**
  - `backend/src/data/competitors.json`
  - `database/prisma/seed-competitors.ts`
  - `backend/src/analysis/competitive-detector.ts`
  - `backend/src/analysis/decision-engine.ts`
  - `backend/src/api/routes/competitive.ts`
  - `backend/src/index.ts`
  - `backend/tests/unit/analysis/competitive-detector.test.ts`

---

## QA Results

### Review Date: 2025-12-05

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Competitive detection and defensive strategy are well defined.

### Improvements Checklist

- [✓] **Rate Limit Behavior:** Updated AC9 to include global rate limit (max 15/day) with opportunityScore prioritization; decision-engine integration code added to Dev Notes
- [✓] **Decision Engine Integration:** Added WHERE/WHEN/HOW integration details with code example in Dev Notes
- [✓] **Multi-Competitor Handling:** Updated AC3 to handle multiple competitors (respond to highest opportunityScore, log all)
- [✓] **Variation Matching Accuracy:** Updated AC3 to accurately describe capability (spaces, hyphens, case - not typos)
- [✓] **Data Source Clarity:** Updated AC2 to clarify database is source of truth
- [✓] **Dashboard Simplification:** Updated AC10 to defer dashboard integration to future story
- [ ] **Variation Matching Performance:** Regex for every competitor keyword might be slow if list grows. For now (small list), it's fine.

### Compliance Check

- Coding Standards: [✓]
- Project Structure: [✓]
- Testing Strategy: [✓]
- All ACs Met: [✓]

### Gate Status

Gate: PASS → docs/qa/gates/2.12-competitive-detector.yml

### Recommended Status

[✓ Ready for Implementation]

