# Story 1.8: Health Check & Monitoring Endpoint

## Status: Draft

## Story

**As a** SRE/operator,  
**I want** a comprehensive health check endpoint that validates all system dependencies including learning system readiness,  
**so that** I can monitor system status, learning algorithm health, and detect failures quickly.

## Acceptance Criteria

1. Health check endpoints implemented:
   - `GET /health` - Basic health check (public, no auth required)
   - `GET /health/detailed` - Extended metrics with sensitive data (requires auth)
   Both return JSON with overall status and component checks
2. Database connectivity check (query Prisma Client, return latency)
3. Twitter API check (verify credentials, return auth status)
4. Reddit API check (verify credentials, return auth status)
5. Threads API check (verify credentials, return auth status)
6. Worker status check (last poll timestamp, posts detected count)
7. **Learning System Health Checks**:
   - Sample size health: Current data availability vs minimum requirements
   - Learning stability indicator: Weight volatility over past 4 weeks
   - False positive rate estimate: Percentage of weight adjustments with insufficient data
   - Last successful weight adjustment timestamp
   - Active A/B tests count and statistical power status
   - Meta-learning accuracy: Success rate of past learning decisions
   - Segmentation coverage: Percentage of segments with sufficient data
8. Overall status: `healthy` (all green), `degraded` (some yellow), `unhealthy` (any red)
9. Endpoint returns 200 if healthy, 503 if unhealthy
10. Response time <500ms for full health check (5s timeout per component)
11. Response includes uptime measurement in seconds via `process.uptime()`

---

## Tasks / Subtasks

- [ ] **Task 1: Create Health Check Service** (AC: 1, 8, 10)
  - [ ] Create `backend/src/services/health-check.ts`
  - [ ] Implement `HealthCheckService` class
  - [ ] Add timeout wrapper for each check (5s max)
  - [ ] Aggregate component statuses
  - [ ] Calculate overall status (healthy/degraded/unhealthy)

- [ ] **Task 2: Implement Database Check** (AC: 2)
  - [ ] Query `SELECT 1` via Prisma
  - [ ] Measure query latency
  - [ ] Return status and latency in ms

- [ ] **Task 3: Implement Platform Checks** (AC: 3, 4, 5)
  - [ ] Check Twitter credentials via `verifyCredentials()`
  - [ ] Check Reddit credentials and get karma
  - [ ] Check Threads credentials (handle unavailable)
  - [ ] Return auth status for each platform

- [ ] **Task 4: Implement Worker Status Check** (AC: 6)
  - [ ] Track last poll timestamp in database or memory
  - [ ] Get current queue depth (unprocessed posts)
  - [ ] Calculate worker health:
    - <15min since last poll = healthy
    - 15-30min = degraded
    - >30min = unhealthy

- [ ] **Task 5: Implement Learning System Checks** (AC: 7)
  - [ ] Check sample size sufficiency for weight adjustment
  - [ ] Calculate learning stability (weight volatility)
  - [ ] Estimate false positive rate
  - [ ] Get last weight adjustment timestamp
  - [ ] Count active experiments
  - [ ] Calculate meta-learning accuracy
  - [ ] Check segmentation coverage

- [ ] **Task 6: Create Basic Health Endpoint** (AC: 1, 9, 11)
  - [ ] Create `backend/src/api/routes/health.ts`
  - [ ] Implement `GET /health` endpoint
  - [ ] Return simplified status (no sensitive data)
  - [ ] Include uptime via `process.uptime()`
  - [ ] Return 200 if healthy, 503 if unhealthy

- [ ] **Task 7: Create Detailed Health Endpoint** (AC: 1, 9)
  - [ ] Implement `GET /health/detailed` endpoint
  - [ ] Add auth middleware
  - [ ] Return full component breakdown
  - [ ] Include learning system health
  - [ ] Include version information

- [ ] **Task 8: Add to Router** (AC: 1)
  - [ ] Register health routes in main Hono app
  - [ ] Ensure `/health` is public (no auth)
  - [ ] Ensure `/health/detailed` requires auth

- [ ] **Task 9: Write Unit Tests** (AC: all)
  - [ ] Test health check aggregation
  - [ ] Test timeout handling
  - [ ] Test status calculation
  - [ ] Test response format

---

## Dev Notes

### Previous Story Insights
- Stories 1.4-1.7 must be complete (platform clients, worker)
- Reuse platform client verification methods
- Learning system tables from Story 1.3

### Health Check Response Format
[Source: epic-1-foundation-core-infrastructure.md#story-1.8]

```json
// GET /health (Basic)
{
  "status": "healthy",
  "uptime": 86400,
  "timestamp": "2025-12-01T12:00:00Z",
  "version": "1.0.0"
}

// GET /health/detailed (Authenticated)
{
  "status": "healthy",
  "components": {
    "database": {
      "status": "healthy",
      "latencyMs": 15
    },
    "twitter": {
      "status": "healthy",
      "authValid": true
    },
    "reddit": {
      "status": "healthy",
      "authValid": true,
      "karma": 127
    },
    "threads": {
      "status": "healthy",
      "authValid": true
    },
    "worker": {
      "status": "healthy",
      "lastPollAt": "2025-12-01T10:30:00Z",
      "queueDepth": 23
    }
  },
  "learning_system": {
    "status": "healthy",
    "sample_size_health": {
      "weight_adjustment": {
        "required": 100,
        "actual": 127,
        "status": "sufficient"
      },
      "archetype_comparison": {
        "required": 50,
        "actual": 48,
        "status": "marginal"
      }
    },
    "learning_stability": "stable",
    "false_positive_rate": 0.09,
    "last_weight_adjustment": "2025-12-01T06:00:00Z",
    "active_experiments": 2,
    "meta_learning_accuracy": 0.87
  },
  "uptime": 86400,
  "timestamp": "2025-12-01T12:00:00Z",
  "version": "1.0.0"
}
```

### Health Check Service Implementation
```typescript
// backend/src/services/health-check.ts

import { prisma } from '../db';
import { TwitterClient } from '../platforms/twitter/client';
import { RedditClient } from '../platforms/reddit/client';
import { ThreadsClient } from '../platforms/threads/client';
import { logger } from '../utils/logger';

interface ComponentStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  [key: string]: any;
}

interface HealthCheckResult {
  status: 'healthy' | 'degraded' | 'unhealthy';
  components: Record<string, ComponentStatus>;
  learning_system?: LearningSystemHealth;
  uptime: number;
  timestamp: string;
  version: string;
}

export class HealthCheckService {
  private twitter: TwitterClient;
  private reddit: RedditClient;
  private threads: ThreadsClient;

  constructor() {
    this.twitter = new TwitterClient();
    this.reddit = new RedditClient();
    this.threads = new ThreadsClient();
  }

  async check(detailed: boolean = false): Promise<HealthCheckResult> {
    const components: Record<string, ComponentStatus> = {};

    // Run all checks with timeout
    const [dbStatus, twitterStatus, redditStatus, threadsStatus, workerStatus] = 
      await Promise.all([
        this.withTimeout(this.checkDatabase(), 5000),
        this.withTimeout(this.checkTwitter(), 5000),
        this.withTimeout(this.checkReddit(), 5000),
        this.withTimeout(this.checkThreads(), 5000),
        this.withTimeout(this.checkWorker(), 5000),
      ]);

    components.database = dbStatus;
    components.twitter = twitterStatus;
    components.reddit = redditStatus;
    components.threads = threadsStatus;
    components.worker = workerStatus;

    const result: HealthCheckResult = {
      status: this.calculateOverallStatus(components),
      components,
      uptime: Math.floor(process.uptime()),
      timestamp: new Date().toISOString(),
      version: process.env.npm_package_version || '1.0.0',
    };

    if (detailed) {
      result.learning_system = await this.checkLearningSystem();
    }

    return result;
  }

  private async checkDatabase(): Promise<ComponentStatus> {
    try {
      const start = Date.now();
      await prisma.$queryRaw`SELECT 1`;
      const latency = Date.now() - start;

      return {
        status: latency < 100 ? 'healthy' : latency < 500 ? 'degraded' : 'unhealthy',
        latencyMs: latency,
      };
    } catch (error) {
      logger.error('Database health check failed', { error });
      return { status: 'unhealthy', error: 'Connection failed' };
    }
  }

  private async checkTwitter(): Promise<ComponentStatus> {
    try {
      const valid = await this.twitter.verifyCredentials();
      return {
        status: valid ? 'healthy' : 'unhealthy',
        authValid: valid,
      };
    } catch (error) {
      return { status: 'unhealthy', authValid: false };
    }
  }

  private async checkReddit(): Promise<ComponentStatus> {
    try {
      const result = await this.reddit.verifyCredentials();
      return {
        status: result.valid ? 'healthy' : 'unhealthy',
        authValid: result.valid,
        karma: result.karma,
      };
    } catch (error) {
      return { status: 'unhealthy', authValid: false, karma: 0 };
    }
  }

  private async checkThreads(): Promise<ComponentStatus> {
    try {
      const result = await this.threads.verifyCredentials();
      return {
        status: result.valid ? 'healthy' : this.threads.isAvailable() ? 'degraded' : 'unhealthy',
        authValid: result.valid,
      };
    } catch (error) {
      return { status: 'degraded', authValid: false };
    }
  }

  private async checkWorker(): Promise<ComponentStatus> {
    // Check last poll timestamp from database or in-memory store
    const lastPoll = await this.getLastPollTimestamp();
    const queueDepth = await this.getQueueDepth();
    
    const minutesSinceLastPoll = lastPoll 
      ? (Date.now() - lastPoll.getTime()) / 1000 / 60 
      : Infinity;

    let status: 'healthy' | 'degraded' | 'unhealthy';
    if (minutesSinceLastPoll < 15) {
      status = 'healthy';
    } else if (minutesSinceLastPoll < 30) {
      status = 'degraded';
    } else {
      status = 'unhealthy';
    }

    return {
      status,
      lastPollAt: lastPoll?.toISOString() || null,
      queueDepth,
    };
  }

  private async checkLearningSystem(): Promise<LearningSystemHealth> {
    // Check sample sizes
    const sampleSizes = await this.getSampleSizes();
    
    // Check learning stability
    const weightLogs = await prisma.weightAdjustmentLog.findMany({
      where: { date: { gte: new Date(Date.now() - 28 * 24 * 60 * 60 * 1000) } },
      orderBy: { date: 'desc' },
    });

    // Check experiments
    const activeExperiments = await prisma.experiment.count({
      where: { status: 'RUNNING' },
    });

    // Check meta-learning accuracy
    const learningEvents = await prisma.learningEvent.findMany({
      where: { evaluatedAt: { not: null } },
      orderBy: { date: 'desc' },
      take: 20,
    });
    
    const accurateEvents = learningEvents.filter(e => 
      e.accuracy !== null && e.accuracy > 0.5
    ).length;
    const metaLearningAccuracy = learningEvents.length > 0 
      ? accurateEvents / learningEvents.length 
      : null;

    return {
      status: 'healthy', // Calculate based on checks
      sample_size_health: sampleSizes,
      learning_stability: this.calculateStability(weightLogs),
      false_positive_rate: this.calculateFalsePositiveRate(weightLogs),
      last_weight_adjustment: weightLogs[0]?.date.toISOString() || null,
      active_experiments: activeExperiments,
      meta_learning_accuracy: metaLearningAccuracy,
    };
  }

  private calculateOverallStatus(components: Record<string, ComponentStatus>): 'healthy' | 'degraded' | 'unhealthy' {
    const statuses = Object.values(components).map(c => c.status);
    
    if (statuses.some(s => s === 'unhealthy')) {
      return 'unhealthy';
    }
    if (statuses.some(s => s === 'degraded')) {
      return 'degraded';
    }
    return 'healthy';
  }

  private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeoutMs)
      ),
    ]).catch(() => ({ status: 'unhealthy' as const, error: 'Timeout' })) as Promise<T>;
  }

  // Helper methods
  private async getLastPollTimestamp(): Promise<Date | null> { /* ... */ }
  private async getQueueDepth(): Promise<number> { /* ... */ }
  private async getSampleSizes(): Promise<any> { /* ... */ }
  private calculateStability(logs: any[]): string { /* ... */ }
  private calculateFalsePositiveRate(logs: any[]): number { /* ... */ }
}
```

### Health Routes
```typescript
// backend/src/api/routes/health.ts

import { Hono } from 'hono';
import { HealthCheckService } from '../../services/health-check';
import { authMiddleware } from '../middleware/auth';

const health = new Hono();
const healthService = new HealthCheckService();

// Basic health check (public)
health.get('/', async (c) => {
  const result = await healthService.check(false);
  
  const statusCode = result.status === 'unhealthy' ? 503 : 200;
  
  return c.json({
    status: result.status,
    uptime: result.uptime,
    timestamp: result.timestamp,
    version: result.version,
  }, statusCode);
});

// Detailed health check (authenticated)
health.get('/detailed', authMiddleware, async (c) => {
  const result = await healthService.check(true);
  
  const statusCode = result.status === 'unhealthy' ? 503 : 200;
  
  return c.json(result, statusCode);
});

export { health };
```

### File Structure
```
backend/src/
├── services/
│   └── health-check.ts          # HealthCheckService
├── api/
│   └── routes/
│       └── health.ts            # Health endpoints
```

---

## Testing

### Test File Location
- `backend/tests/unit/services/health-check.test.ts`
- `backend/tests/integration/api/health.test.ts`

### Testing Standards
- Mock all external dependencies
- Test timeout handling
- Test status calculation logic
- Test response format

### Story-Specific Testing Requirements
1. `/health` returns 200 when healthy
2. `/health` returns 503 when unhealthy
3. Response time <500ms
4. All component checks run with timeout
5. Learning system health calculated correctly

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

