# Story 2.5: Decision Score Calculation & Mode Selection with Segmented Weights

## Status: Draft

## Story

**As a** the decision engine,  
**I want** to combine all four signal scores using context-specific weights and select operational mode,  
**so that** the bot chooses the appropriate engagement strategy optimized for each platform and time context.

## Acceptance Criteria

1. Module created at `@backend/analysis/decision-engine.ts`
2. **Segmented Weight Retrieval** (integrated with Story 4.6 Priority 2):
   - Query `segmented_weights` table for context-specific weights
   - Priority order: Combined segment (e.g., "TWITTER_MORNING") → Platform → Global fallback
   - If segment has insufficient data (<50 decisions), fall back to parent segment
   - Implementation: `getWeights(context: { platform, timestamp })` returns most specific available weights
   - Database query: `SELECT * FROM segmented_weights WHERE segment_type = ? AND segment_key = ?`
   - Fallback logic: Try combined → Try platform → Use global defaults
3. Composite Decision Score calculation:
   - If TRS < 0.5 → Disengage (metaphor/unrelated topic)
   - Else: Context-weighted average using segmented weights
   - **Robustness check**: Ensure weights are based on sufficient sample sizes
   - Example: Twitter morning may use (SSS×45% + ARS×20% + EVS×25% + TRS×10%)
   - Example: Reddit evening may use (SSS×50% + ARS×30% + EVS×10% + TRS×10%)
4. Mode selection logic implemented per project brief decision stack:
   - SSS ≥ 0.82 → **Helpful Mode** (mandatory)
   - 0.55 ≤ SSS < 0.82 AND EVS > 5.0× → **Engagement Mode** (unless ARS > 0.70 → **Hybrid**)
   - SSS < 0.55 → **Engagement Mode** or **Disengaged** (no hard pitch)
   - Any safety flag → **Disengaged Mode**
5. Decision object created with all scores, composite score, mode, segment used, timestamp
6. Decision written to `decisions` table with foreign key to `posts`
7. Unit tests validate mode selection for 50+ scenario combinations
8. Integration test: Process sample post → retrieve correct segment weights → store decision
9. Dashboard query endpoint `/api/decisions` returns recent decisions with scores and segment context

---

## Tasks / Subtasks

- [ ] **Task 1: Create Decision Engine Module** (AC: 1)
  - [ ] Create `backend/src/analysis/decision-engine.ts`
  - [ ] Create DecisionEngine class
  - [ ] Define decision result interface
  - [ ] Implement main `analyzePost(post, author)` method

- [ ] **Task 2: Implement Segmented Weight Retrieval** (AC: 2)
  - [ ] Create `getWeights(context)` method
  - [ ] Query segmented_weights table
  - [ ] Implement priority fallback: combined → platform → global
  - [ ] Check sample size sufficiency (<50 → fallback)
  - [ ] Return weight object with segment metadata

- [ ] **Task 3: Implement Composite Score Calculation** (AC: 3)
  - [ ] TRS gate check (< 0.5 → immediate disengage)
  - [ ] Apply context-specific weights to signals
  - [ ] Calculate weighted average
  - [ ] Normalize EVS ratio to 0-1 scale
  - [ ] Return composite score 0.0-1.0

- [ ] **Task 4: Implement Mode Selection Logic** (AC: 4)
  - [ ] SSS ≥ 0.82 → HELPFUL (mandatory)
  - [ ] 0.55 ≤ SSS < 0.82 → Context-dependent
  - [ ] EVS > 5.0 → ENGAGEMENT (unless ARS > 0.70 → HYBRID)
  - [ ] SSS < 0.55 → ENGAGEMENT or DISENGAGED
  - [ ] Safety flag override → DISENGAGED
  - [ ] Power user consideration

- [ ] **Task 5: Integrate All Signals** (AC: 5)
  - [ ] Call all 4 signal analyzers in parallel
  - [ ] Call safety protocol check
  - [ ] Call power user detector
  - [ ] Call competitive detector
  - [ ] Call temporal intelligence
  - [ ] Aggregate all results into decision object

- [ ] **Task 6: Save Decision to Database** (AC: 6)
  - [ ] Create decision record in decisions table
  - [ ] Store all signal scores
  - [ ] Store composite score and mode
  - [ ] Store signals_json with full breakdown
  - [ ] Store temporal_context
  - [ ] Store segment used for weights
  - [ ] Link to post via foreign key

- [ ] **Task 7: Create Dashboard API** (AC: 9)
  - [ ] Create `backend/src/api/routes/decisions.ts`
  - [ ] Implement `GET /api/decisions` endpoint
  - [ ] Support filtering by platform, mode, date range
  - [ ] Return decisions with post context
  - [ ] Include segment information

- [ ] **Task 8: Write Unit Tests** (AC: 7)
  - [ ] Test 50+ scenario combinations
  - [ ] Test all mode selection rules
  - [ ] Test weight retrieval fallback logic
  - [ ] Test TRS gate (< 0.5)
  - [ ] Test safety override
  - [ ] Test power user handling

- [ ] **Task 9: Write Integration Test** (AC: 8)
  - [ ] Seed database with test post and author
  - [ ] Process through decision engine
  - [ ] Verify correct segment weights retrieved
  - [ ] Verify decision saved to database
  - [ ] Verify all fields populated correctly

---

## Dev Notes

### Previous Story Insights
- Stories 2.1-2.4 complete (all 4 signal analyzers)
- This story integrates all signals into final decision
- Critical integration point for entire Epic 2

### Decision Engine Implementation
[Source: architecture.md#7.2-core-domain-modules]

```typescript
// backend/src/analysis/decision-engine.ts

import { Post, Author, Platform, OperationalMode } from '@prisma/client';
import { prisma } from '../db';
import { analyzeLinguisticIntent } from './signal-1-linguistic';
import { analyzeAuthorContext } from './signal-2-author';
import { analyzePostVelocity } from './signal-3-velocity';
import { analyzeSemanticTopic } from './signal-4-semantic';
import { checkSafetyProtocol } from './safety-protocol';
import { detectPowerUser } from './power-user-detector';
import { detectCompetitor } from './competitive-detector';
import { getTemporalContext } from './temporal-intelligence';
import { logger } from '../utils/logger';

interface DecisionContext {
  platform: Platform;
  timestamp: Date;
  timeOfDay: 'MORNING' | 'AFTERNOON' | 'EVENING' | 'NIGHT';
  dayOfWeek: 'WEEKDAY' | 'WEEKEND';
}

interface SignalWeights {
  sssWeight: number;
  arsWeight: number;
  evsWeight: number;
  trsWeight: number;
  segmentType: string;
  segmentKey: string;
  sampleSize: number;
}

interface DecisionResult {
  postId: string;
  sssScore: number;
  arsScore: number;
  evsScore: number; // Ratio, not 0-1
  trsScore: number;
  compositeScore: number;
  mode: OperationalMode;
  archetype: string | null;
  safetyFlags: string[];
  signalsJson: any;
  temporalContext: any;
  competitorDetected: string | null;
  isPowerUser: boolean;
  segmentUsed: string;
}

const DEFAULT_WEIGHTS: SignalWeights = {
  sssWeight: 0.40,
  arsWeight: 0.25,
  evsWeight: 0.20,
  trsWeight: 0.15,
  segmentType: 'GLOBAL',
  segmentKey: 'DEFAULT',
  sampleSize: 0,
};

export class DecisionEngine {
  async analyzePost(post: Post, author: Author): Promise<DecisionResult> {
    try {
      // Get decision context
      const context = this.getDecisionContext(post);

      // Run all signals in parallel
      const [sss, ars, evs, trs, safety, powerUser, competitor, temporal] =
        await Promise.all([
          analyzeLinguisticIntent(post.content),
          analyzeAuthorContext(post.platform, author.platformId, author.handle),
          analyzePostVelocity(post, author),
          analyzeSemanticTopic(post.content),
          checkSafetyProtocol(post.content, author),
          detectPowerUser(author),
          detectCompetitor(post.content),
          getTemporalContext(),
        ]);

      // Safety override - immediate disengage
      if (safety.shouldDisengage) {
        return this.createDisengagedDecision(post, safety.flags, {
          sss, ars, evs, trs, powerUser, competitor, temporal,
        });
      }

      // Topic relevance gate
      if (trs.score < 0.5) {
        return this.createDisengagedDecision(post, ['LOW_TOPIC_RELEVANCE'], {
          sss, ars, evs, trs, powerUser, competitor, temporal,
        });
      }

      // Get context-specific weights
      const weights = await this.getWeights(context);

      // Calculate composite score
      const compositeScore = this.calculateComposite(sss, ars, evs, trs, weights);

      // Select operational mode
      const mode = this.selectMode(sss, ars, evs, powerUser, safety);

      // Create decision result
      const decision: DecisionResult = {
        postId: post.id,
        sssScore: sss.score,
        arsScore: ars.score,
        evsScore: evs.ratio,
        trsScore: trs.score,
        compositeScore,
        mode,
        archetype: null, // Set in Story 2.10
        safetyFlags: safety.flags,
        signalsJson: { sss, ars, evs, trs },
        temporalContext: temporal,
        competitorDetected: competitor.detected ? competitor.name : null,
        isPowerUser: powerUser.isPowerUser,
        segmentUsed: `${weights.segmentType}_${weights.segmentKey}`,
      };

      // Save to database
      await this.saveDecision(decision);

      return decision;
    } catch (error) {
      logger.error('Decision engine failed', { error, postId: post.id });
      throw error;
    }
  }

  private async getWeights(context: DecisionContext): Promise<SignalWeights> {
    try {
      // Try combined segment (e.g., TWITTER_MORNING)
      const combinedKey = `${context.platform}_${context.timeOfDay}`;
      let weights = await prisma.segmentedWeight.findUnique({
        where: {
          segmentType_segmentKey: {
            segmentType: 'COMBINED',
            segmentKey: combinedKey,
          },
        },
      });

      // Check sample size sufficiency
      if (weights && weights.sampleSize >= 50) {
        return this.formatWeights(weights, 'COMBINED', combinedKey);
      }

      // Try platform segment
      weights = await prisma.segmentedWeight.findUnique({
        where: {
          segmentType_segmentKey: {
            segmentType: 'PLATFORM',
            segmentKey: context.platform,
          },
        },
      });

      if (weights && weights.sampleSize >= 50) {
        return this.formatWeights(weights, 'PLATFORM', context.platform);
      }

      // Fall back to global defaults
      logger.debug('Using default weights', { context });
      return DEFAULT_WEIGHTS;
    } catch (error) {
      logger.error('Weight retrieval failed', { error, context });
      return DEFAULT_WEIGHTS;
    }
  }

  private formatWeights(
    weights: any,
    segmentType: string,
    segmentKey: string
  ): SignalWeights {
    return {
      sssWeight: weights.sssWeight,
      arsWeight: weights.arsWeight,
      evsWeight: weights.evsWeight,
      trsWeight: weights.trsWeight,
      segmentType,
      segmentKey,
      sampleSize: weights.sampleSize,
    };
  }

  private calculateComposite(
    sss: any,
    ars: any,
    evs: any,
    trs: any,
    weights: SignalWeights
  ): number {
    // Normalize EVS ratio to 0-1 scale (cap at 5x)
    const evsNormalized = Math.min(evs.ratio / 5, 1);

    return (
      sss.score * weights.sssWeight +
      ars.score * weights.arsWeight +
      evsNormalized * weights.evsWeight +
      trs.score * weights.trsWeight
    );
  }

  private selectMode(
    sss: any,
    ars: any,
    evs: any,
    powerUser: any,
    safety: any
  ): OperationalMode {
    // Safety override
    if (safety.shouldDisengage) {
      return 'DISENGAGED';
    }

    // SSS ≥ 0.82 → Mandatory Helpful Mode
    if (sss.score >= 0.82) {
      return 'HELPFUL';
    }

    // 0.55 ≤ SSS < 0.82 → Context-dependent
    if (sss.score >= 0.55) {
      // High velocity (viral) → Engagement unless strong relationship
      if (evs.ratio > 5.0) {
        return ars.score > 0.70 ? 'HYBRID' : 'ENGAGEMENT';
      }
      // Power user → Premium Helpful
      if (powerUser.isPowerUser) {
        return 'HELPFUL';
      }
      // Default to Hybrid
      return 'HYBRID';
    }

    // SSS < 0.55 → Engagement or Disengage
    if (evs.ratio > 2.0) {
      return 'ENGAGEMENT';
    }

    return 'DISENGAGED';
  }

  private getDecisionContext(post: Post): DecisionContext {
    const timestamp = post.detectedAt;
    const hour = timestamp.getHours();
    const day = timestamp.getDay();

    return {
      platform: post.platform,
      timestamp,
      timeOfDay: this.getTimeOfDay(hour),
      dayOfWeek: day === 0 || day === 6 ? 'WEEKEND' : 'WEEKDAY',
    };
  }

  private getTimeOfDay(hour: number): 'MORNING' | 'AFTERNOON' | 'EVENING' | 'NIGHT' {
    if (hour >= 6 && hour < 12) return 'MORNING';
    if (hour >= 12 && hour < 18) return 'AFTERNOON';
    if (hour >= 18 && hour < 22) return 'EVENING';
    return 'NIGHT';
  }

  private async saveDecision(decision: DecisionResult): Promise<void> {
    await prisma.decision.create({
      data: {
        postId: decision.postId,
        sssScore: decision.sssScore,
        arsScore: decision.arsScore,
        evsScore: decision.evsScore,
        trsScore: decision.trsScore,
        compositeScore: decision.compositeScore,
        mode: decision.mode,
        archetype: decision.archetype,
        safetyFlags: decision.safetyFlags,
        signalsJson: decision.signalsJson,
        temporalContext: decision.temporalContext,
        competitorDetected: decision.competitorDetected,
        isPowerUser: decision.isPowerUser,
      },
    });
  }

  private createDisengagedDecision(
    post: Post,
    flags: string[],
    signals: any
  ): DecisionResult {
    return {
      postId: post.id,
      sssScore: signals.sss.score,
      arsScore: signals.ars.score,
      evsScore: signals.evs.ratio,
      trsScore: signals.trs.score,
      compositeScore: 0.0,
      mode: 'DISENGAGED',
      archetype: null,
      safetyFlags: flags,
      signalsJson: signals,
      temporalContext: signals.temporal,
      competitorDetected: signals.competitor?.detected ? signals.competitor.name : null,
      isPowerUser: signals.powerUser.isPowerUser,
      segmentUsed: 'DISENGAGED',
    };
  }
}

// Export singleton
export const decisionEngine = new DecisionEngine();
```

### Mode Selection Decision Tree
```
┌─────────────────────────────────┐
│  Safety Check                   │
│  Any safety flag?               │
└─────────┬───────────────────────┘
          │
          ├─ YES → DISENGAGED
          │
          └─ NO
             │
      ┌──────▼──────────────────────┐
      │  Topic Relevance Check      │
      │  TRS < 0.5?                 │
      └──────┬──────────────────────┘
             │
             ├─ YES → DISENGAGED
             │
             └─ NO
                │
         ┌──────▼──────────────────────┐
         │  SSS ≥ 0.82?                │
         └──────┬──────────────────────┘
                │
                ├─ YES → HELPFUL
                │
                └─ NO
                   │
            ┌──────▼──────────────────────┐
            │  0.55 ≤ SSS < 0.82?         │
            └──────┬──────────────────────┘
                   │
                   ├─ YES
                   │   │
                   │   ├─ EVS > 5.0 AND ARS > 0.70? → HYBRID
                   │   ├─ EVS > 5.0? → ENGAGEMENT
                   │   ├─ Power User? → HELPFUL
                   │   └─ Default → HYBRID
                   │
                   └─ NO (SSS < 0.55)
                       │
                       ├─ EVS > 2.0? → ENGAGEMENT
                       └─ Default → DISENGAGED
```

### File Structure
```
backend/src/
├── analysis/
│   ├── signal-1-linguistic.ts
│   ├── signal-2-author.ts
│   ├── signal-3-velocity.ts
│   ├── signal-4-semantic.ts
│   ├── safety-protocol.ts       # Story 2.6
│   ├── power-user-detector.ts   # Story 2.11
│   ├── competitive-detector.ts  # Story 2.12
│   ├── temporal-intelligence.ts # Story 2.9
│   └── decision-engine.ts       # THIS STORY - integrates all
└── api/
    └── routes/
        └── decisions.ts         # Dashboard API
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/decision-engine.test.ts`
- `backend/tests/integration/analysis/decision-flow.test.ts`

### Testing Standards
- Mock all signal analyzers
- Mock database queries
- Test all mode selection paths
- Test weight retrieval logic

### Story-Specific Testing Requirements
1. Test 50+ scenario combinations
2. SSS ≥ 0.82 always returns HELPFUL
3. Safety flags override to DISENGAGED
4. TRS < 0.5 returns DISENGAGED
5. Weight retrieval tries combined → platform → global
6. Sample size check (<50 triggers fallback)
7. Decision saved to database correctly
8. Composite score calculated correctly

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

