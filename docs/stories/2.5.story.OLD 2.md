# Story 2.5: Decision Score Calculation & Mode Selection with Segmented Weights

## Status: Draft

## Story

**As a** the decision engine,  
**I want** to combine all four signal scores using context-specific weights and select operational mode,  
**so that** the bot chooses the appropriate engagement strategy optimized for each platform and time context.

## Acceptance Criteria

1. Module created at `@backend/analysis/decision-engine.ts`
2. **Segmented Weight Retrieval** (integrated with Story 4.6 Priority 2):
   - Query `segmented_weights` table for context-specific weights
   - Priority order: Combined segment (e.g., "TWITTER_MORNING") → Platform → Global fallback
   - If segment has insufficient data (<50 decisions), fall back to parent segment
   - Implementation: `getWeights(context: { platform, timestamp })` returns most specific available weights
   - Database query: `SELECT * FROM segmented_weights WHERE segment_type = ? AND segment_key = ?`
   - Fallback logic: Try combined → Try platform → Use global defaults
3. Composite Decision Score calculation:
   - If TRS < 0.5 → Disengage (metaphor/unrelated topic)
   - Else: Context-weighted average using segmented weights
   - **Robustness check**: Ensure weights are based on sufficient sample sizes
   - Example: Twitter morning may use (SSS×45% + ARS×20% + EVS×25% + TRS×10%)
   - Example: Reddit evening may use (SSS×50% + ARS×30% + EVS×10% + TRS×10%)
4. Mode selection logic implemented per project brief decision stack:
   - SSS ≥ 0.82 → **Helpful Mode** (mandatory)
   - 0.55 ≤ SSS < 0.82 AND EVS > 5.0× → **Engagement Mode** (unless ARS > 0.70 → **Hybrid**)
   - SSS < 0.55 → **Engagement Mode** or **Disengaged** (no hard pitch)
   - Any safety flag → **Disengaged Mode**
5. **Archetype Selection Integration**:
   - Once mode is selected, call the Archetype Selector (Story 2.10) to determine the specific persona strategy.
   - Pass mode, author context, and post content to the selector.
6. Decision object created with all scores, composite score, mode, archetype, segment used, timestamp
7. Decision written to `decisions` table with foreign key to `posts`
8. Unit tests validate mode selection for 50+ scenario combinations
9. Integration test: Process sample post → retrieve correct segment weights → store decision
10. Dashboard query endpoint `/api/decisions` returns recent decisions with scores and segment context

---

## Prerequisites

**CRITICAL DEPENDENCIES:** This story requires the following modules to be implemented first:
- **Story 2.6**: Safety Protocol
- **Story 2.9**: Temporal Intelligence Engine
- **Story 2.11**: Power User Detector
- **Story 2.12**: Competitive Intelligence Detector
- **Story 2.10**: Archetype Selection Engine

Do not attempt implementation until these dependencies are available.

---

## Tasks / Subtasks

- [ ] **Task 1: Create Decision Engine Module** (AC: 1)
  - [ ] Create `backend/src/analysis/decision-engine.ts`
  - [ ] Create DecisionEngine class
  - [ ] Define decision result interface
  - [ ] Implement main `analyzePost(post, author)` method

- [ ] **Task 2: Implement Segmented Weight Retrieval** (AC: 2)
  - [ ] Create `getWeights(context)` method
  - [ ] Query segmented_weights table
  - [ ] Implement priority fallback: combined → platform → global
  - [ ] Check sample size sufficiency (<50 → fallback)
  - [ ] Return weight object with segment metadata

- [ ] **Task 3: Implement Composite Score Calculation** (AC: 3)
  - [ ] TRS gate check (< 0.5 → immediate disengage)
  - [ ] Apply context-specific weights to signals
  - [ ] Calculate weighted average
  - [ ] Normalize EVS ratio to 0-1 scale
  - [ ] Return composite score 0.0-1.0

- [ ] **Task 4: Implement Mode Selection Logic** (AC: 4)
  - [ ] SSS ≥ 0.82 → HELPFUL (mandatory)
  - [ ] 0.55 ≤ SSS < 0.82 → Context-dependent
  - [ ] EVS > 5.0 → ENGAGEMENT (unless ARS > 0.70 → HYBRID)
  - [ ] SSS < 0.55 → ENGAGEMENT or DISENGAGED
  - [ ] Safety flag override → DISENGAGED
  - [ ] Power user consideration

- [ ] **Task 5: Integrate All Signals & Archetypes** (AC: 5)
  - [ ] Call all 4 signal analyzers in parallel
  - [ ] Call safety protocol check (Story 2.6)
  - [ ] Call power user detector (Story 2.11)
  - [ ] Call competitive detector (Story 2.12)
  - [ ] Call temporal intelligence (Story 2.9)
  - [ ] Aggregate all results into decision object
  - [ ] **NEW:** Call Archetype Selector (Story 2.10) with selected mode

- [ ] **Task 6: Save Decision to Database** (AC: 6)
  - [ ] Create decision record in decisions table
  - [ ] Store all signal scores
  - [ ] Store composite score, mode, and archetype
  - [ ] Store signals_json with full breakdown
  - [ ] Store temporal_context
  - [ ] Store segment used for weights
  - [ ] Link to post via foreign key

- [ ] **Task 7: Create Dashboard API** (AC: 9)
  - [ ] Create `backend/src/api/routes/decisions.ts`
  - [ ] Implement `GET /api/decisions` endpoint
  - [ ] Support filtering by platform, mode, date range
  - [ ] Return decisions with post context
  - [ ] Include segment information

- [ ] **Task 8: Write Unit Tests** (AC: 7)
  - [ ] Test 50+ scenario combinations
  - [ ] Test all mode selection rules
  - [ ] Test weight retrieval fallback logic
  - [ ] Test TRS gate (< 0.5)
  - [ ] Test safety override
  - [ ] Test power user handling
  - [ ] Test archetype integration

- [ ] **Task 9: Write Integration Test** (AC: 8)
  - [ ] Seed database with test post and author
  - [ ] Process through decision engine
  - [ ] Verify correct segment weights retrieved
  - [ ] Verify decision saved to database
  - [ ] Verify all fields populated correctly

---

## Dev Notes

### Previous Story Insights
- Stories 2.1-2.4 complete (all 4 signal analyzers)
- Stories 2.6, 2.9, 2.10, 2.11, 2.12 MUST be complete before this story.
- This story integrates all signals into final decision
- Critical integration point for entire Epic 2

### Decision Engine Implementation
[Source: architecture.md#7.2-core-domain-modules]

```typescript
// backend/src/analysis/decision-engine.ts

import { Post, Author, Platform, OperationalMode } from '@prisma/client';
import { prisma } from '../db';
import { analyzeLinguisticIntent } from './signal-1-linguistic';
import { analyzeAuthorContext } from './signal-2-author';
import { analyzePostVelocity } from './signal-3-velocity';
import { analyzeSemanticTopic } from './signal-4-semantic';
import { checkSafetyProtocol } from './safety-protocol';
import { detectPowerUser } from './power-user-detector';
import { detectCompetitor } from './competitive-detector';
import { getTemporalContext } from './temporal-intelligence';
import { archetypeSelector } from '../generation/archetype-selector'; // Story 2.10
import { logger } from '../utils/logger';

interface DecisionContext {
  platform: Platform;
  timestamp: Date;
  timeOfDay: 'MORNING' | 'AFTERNOON' | 'EVENING' | 'NIGHT';
  dayOfWeek: 'WEEKDAY' | 'WEEKEND';
}

interface SignalWeights {
  sssWeight: number;
  arsWeight: number;
  evsWeight: number;
  trsWeight: number;
  segmentType: string;
  segmentKey: string;
  sampleSize: number;
}

interface DecisionResult {
  postId: string;
  sssScore: number;
  arsScore: number;
  evsScore: number; // Ratio, not 0-1
  trsScore: number;
  compositeScore: number;
  mode: OperationalMode;
  archetype: string | null;
  safetyFlags: string[];
  signalsJson: any;
  temporalContext: any;
  competitorDetected: string | null;
  isPowerUser: boolean;
  segmentUsed: string;
}

const DEFAULT_WEIGHTS: SignalWeights = {
  sssWeight: 0.40,
  arsWeight: 0.25,
  evsWeight: 0.20,
  trsWeight: 0.15,
  segmentType: 'GLOBAL',
  segmentKey: 'DEFAULT',
  sampleSize: 0,
};

export class DecisionEngine {
  async analyzePost(post: Post, author: Author): Promise<DecisionResult> {
    try {
      // Get decision context
      const context = this.getDecisionContext(post);

      // Run all signals in parallel
      const [sss, ars, evs, trs, safety, powerUser, competitor, temporal] =
        await Promise.all([
          analyzeLinguisticIntent(post.content),
          analyzeAuthorContext(post.platform, author.platformId, author.handle),
          analyzePostVelocity(post, author),
          analyzeSemanticTopic(post.content),
          checkSafetyProtocol(post.content, author),
          detectPowerUser(author),
          detectCompetitor(post.content),
          getTemporalContext(),
        ]);

      // Safety override - immediate disengage
      if (safety.shouldDisengage) {
        return this.createDisengagedDecision(post, safety.flags, {
          sss, ars, evs, trs, powerUser, competitor, temporal,
        });
      }

      // Topic relevance gate
      if (trs.score < 0.5) {
        return this.createDisengagedDecision(post, ['LOW_TOPIC_RELEVANCE'], {
          sss, ars, evs, trs, powerUser, competitor, temporal,
        });
      }

      // Get context-specific weights
      const weights = await this.getWeights(context);

      // Calculate composite score
      const compositeScore = this.calculateComposite(sss, ars, evs, trs, weights);

      // Select operational mode
      const mode = this.selectMode(sss, ars, evs, powerUser, safety);

      // Select Archetype (Story 2.10 Integration)
      let archetype = null;
      if (mode !== 'DISENGAGED') {
        const selection = await archetypeSelector.selectArchetype(
          mode, 
          author, 
          post, 
          powerUser.isPowerUser, 
          competitor.detected ? competitor.name : null
        );
        archetype = selection.archetype;
      }

      // Create decision result
      const decision: DecisionResult = {
        postId: post.id,
        sssScore: sss.score,
        arsScore: ars.score,
        evsScore: evs.ratio,
        trsScore: trs.score,
        compositeScore,
        mode,
        archetype,
        safetyFlags: safety.flags,
        signalsJson: { sss, ars, evs, trs },
        temporalContext: temporal,
        competitorDetected: competitor.detected ? competitor.name : null,
        isPowerUser: powerUser.isPowerUser,
        segmentUsed: `${weights.segmentType}_${weights.segmentKey}`,
      };

      // Save to database
      await this.saveDecision(decision);

      return decision;
    } catch (error) {
      logger.error('Decision engine failed', { error, postId: post.id });
      throw error;
    }
  }

  private async getWeights(context: DecisionContext): Promise<SignalWeights> {
    try {
      // Try combined segment (e.g., TWITTER_MORNING)
      const combinedKey = `${context.platform}_${context.timeOfDay}`;
      let weights = await prisma.segmentedWeight.findUnique({
        where: {
          segmentType_segmentKey: {
            segmentType: 'COMBINED',
            segmentKey: combinedKey,
          },
        },
      });

      // Check sample size sufficiency
      if (weights && weights.sampleSize >= 50) {
        return this.formatWeights(weights, 'COMBINED', combinedKey);
      }

      // Try platform segment
      weights = await prisma.segmentedWeight.findUnique({
        where: {
          segmentType_segmentKey: {
            segmentType: 'PLATFORM',
            segmentKey: context.platform,
          },
        },
      });

      if (weights && weights.sampleSize >= 50) {
        return this.formatWeights(weights, 'PLATFORM', context.platform);
      }

      // Fall back to global defaults
      logger.debug('Using default weights', { context });
      return DEFAULT_WEIGHTS;
    } catch (error) {
      logger.error('Weight retrieval failed', { error, context });
      return DEFAULT_WEIGHTS;
    }
  }

  private formatWeights(
    weights: any,
    segmentType: string,
    segmentKey: string
  ): SignalWeights {
    return {
      sssWeight: weights.sssWeight,
      arsWeight: weights.arsWeight,
      evsWeight: weights.evsWeight,
      trsWeight: weights.trsWeight,
      segmentType,
      segmentKey,
      sampleSize: weights.sampleSize,
    };
  }

  private calculateComposite(
    sss: any,
    ars: any,
    evs: any,
    trs: any,
    weights: SignalWeights
  ): number {
    // Normalize EVS ratio to 0-1 scale (cap at 5x)
    const evsNormalized = Math.min(evs.ratio / 5, 1);

    return (
      sss.score * weights.sssWeight +
      ars.score * weights.arsWeight +
      evsNormalized * weights.evsWeight +
      trs.score * weights.trsWeight
    );
  }

  private selectMode(
    sss: any,
    ars: any,
    evs: any,
    powerUser: any,
    safety: any
  ): OperationalMode {
    // Safety override
    if (safety.shouldDisengage) {
      return 'DISENGAGED';
    }

    // SSS ≥ 0.82 → Mandatory Helpful Mode
    if (sss.score >= 0.82) {
      return 'HELPFUL';
    }

    // 0.55 ≤ SSS < 0.82 → Context-dependent
    if (sss.score >= 0.55) {
      // High velocity (viral) → Engagement unless strong relationship
      if (evs.ratio > 5.0) {
        return ars.score > 0.70 ? 'HYBRID' : 'ENGAGEMENT';
      }
      // Power user → Premium Helpful
      if (powerUser.isPowerUser) {
        return 'HELPFUL';
      }
      // Default to Hybrid
      return 'HYBRID';
    }

    // SSS < 0.55 → Engagement or Disengage
    if (evs.ratio > 2.0) {
      return 'ENGAGEMENT';
    }

    return 'DISENGAGED';
  }

  private getDecisionContext(post: Post): DecisionContext {
    const timestamp = post.detectedAt;
    const hour = timestamp.getHours();
    const day = timestamp.getDay();

    return {
      platform: post.platform,
      timestamp,
      timeOfDay: this.getTimeOfDay(hour),
      dayOfWeek: day === 0 || day === 6 ? 'WEEKEND' : 'WEEKDAY',
    };
  }

  private getTimeOfDay(hour: number): 'MORNING' | 'AFTERNOON' | 'EVENING' | 'NIGHT' {
    if (hour >= 6 && hour < 12) return 'MORNING';
    if (hour >= 12 && hour < 18) return 'AFTERNOON';
    if (hour >= 18 && hour < 22) return 'EVENING';
    return 'NIGHT';
  }

  private async saveDecision(decision: DecisionResult): Promise<void> {
    await prisma.decision.create({
      data: {
        postId: decision.postId,
        sssScore: decision.sssScore,
        arsScore: decision.arsScore,
        evsScore: decision.evsScore,
        trsScore: decision.trsScore,
        compositeScore: decision.compositeScore,
        mode: decision.mode,
        archetypeId: decision.archetype ? 
          (await prisma.archetype.findUnique({ where: { name: decision.archetype } }))?.id 
          : null,
        safetyFlags: decision.safetyFlags,
        signalsJson: decision.signalsJson,
        temporalContext: decision.temporalContext,
        competitorDetected: decision.competitorDetected !== null,
        isPowerUser: decision.isPowerUser,
      },
    });
  }

  private createDisengagedDecision(
    post: Post,
    flags: string[],
    signals: any
  ): DecisionResult {
    return {
      postId: post.id,
      sssScore: signals.sss.score,
      arsScore: signals.ars.score,
      evsScore: signals.evs.ratio,
      trsScore: signals.trs.score,
      compositeScore: 0.0,
      mode: 'DISENGAGED',
      archetype: null,
      safetyFlags: flags,
      signalsJson: signals,
      temporalContext: signals.temporal,
      competitorDetected: signals.competitor?.detected ? signals.competitor.name : null,
      isPowerUser: signals.powerUser.isPowerUser,
      segmentUsed: 'DISENGAGED',
    };
  }
}

// Export singleton
export const decisionEngine = new DecisionEngine();
```

### Mode Selection Decision Tree
```
┌─────────────────────────────────┐
│  Safety Check                   │
│  Any safety flag?               │
└─────────┬───────────────────────┘
          │
          ├─ YES → DISENGAGED
          │
          └─ NO
             │
      ┌──────▼──────────────────────┐
      │  Topic Relevance Check      │
      │  TRS < 0.5?                 │
      └──────┬──────────────────────┘
             │
             ├─ YES → DISENGAGED
             │
             └─ NO
                │
         ┌──────▼──────────────────────┐
         │  SSS ≥ 0.82?                │
         └──────┬──────────────────────┘
                │
                ├─ YES → HELPFUL
                │
                └─ NO
                   │
            ┌──────▼──────────────────────┐
            │  0.55 ≤ SSS < 0.82?         │
            └──────┬──────────────────────┘
                   │
                   ├─ YES
                   │   │
                   │   ├─ EVS > 5.0 AND ARS > 0.70? → HYBRID
                   │   ├─ EVS > 5.0? → ENGAGEMENT
                   │   ├─ Power User? → HELPFUL
                   │   └─ Default → HYBRID
                   │
                   └─ NO (SSS < 0.55)
                       │
                       ├─ EVS > 2.0? → ENGAGEMENT
                       └─ Default → DISENGAGED
```

### File Structure
```
backend/src/
├── analysis/
│   ├── signal-1-linguistic.ts
│   ├── signal-2-author.ts
│   ├── signal-3-velocity.ts
│   ├── signal-4-semantic.ts
│   ├── safety-protocol.ts       # Story 2.6
│   ├── power-user-detector.ts   # Story 2.11
│   ├── competitive-detector.ts  # Story 2.12
│   ├── temporal-intelligence.ts # Story 2.9
│   └── decision-engine.ts       # THIS STORY - integrates all
└── api/
    └── routes/
        └── decisions.ts         # Dashboard API
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/decision-engine.test.ts`
- `backend/tests/integration/analysis/decision-flow.test.ts`

### Testing Standards
- Mock all signal analyzers
- Mock database queries
- Test all mode selection paths
- Test weight retrieval logic

### Story-Specific Testing Requirements
1. Test 50+ scenario combinations
2. SSS ≥ 0.82 always returns HELPFUL
3. Safety flags override to DISENGAGED
4. TRS < 0.5 returns DISENGAGED
5. Weight retrieval tries combined → platform → global
6. Sample size check (<50 triggers fallback)
7. Decision saved to database correctly
8. Composite score calculated correctly
9. Archetype Selector is called when mode != DISENGAGED

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |
| 2025-12-05 | 1.1 | Integrated dependencies and Archetype Selector | John (PM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results

### Review Date: 2025-12-05

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Integration logic is solid. Strict dependency on Stories 2.6, 2.9, 2.10, 2.11, 2.12 is noted.

### Improvements Checklist

- [ ] **Dependency Check:** Ensure `segmented_weights` table exists (from Epic 1 or 4) before implementing Task 2.
- [ ] **Logic Verification:** Verify that `distress > 0.6` in Safety Protocol (Story 2.6) is achievable if we want purely sentiment-based disengagement (currently requires flags to exceed 0.5).

### Compliance Check

- Coding Standards: [✓]
- Project Structure: [✓]
- Testing Strategy: [✓]
- All ACs Met: [✓]

### Gate Status

Gate: PASS → docs/qa/gates/2.5-decision-engine.yml

### Recommended Status

[✓ Ready for Implementation]

---

### Review Date: 2025-12-06

### Reviewed By: Quinn (Test Architect)

### Review Type: Comprehensive Pre-Implementation Deep Analysis

**CRITICAL NOTICE**: This review supersedes the 2025-12-05 review. A deep mathematical and architectural analysis reveals **fundamental flaws** requiring major redesign before implementation.

### Executive Summary

**GATE DECISION: FAIL** → Story 2.5 is **NOT READY FOR IMPLEMENTATION**.

**Risk Score**: 21/100 (EXTREMELY HIGH RISK)
**NFR Score**: 40/100 (FAIL)
**Quality Score**: 21/100 (FAIL)

**Total Risks Identified**: 23
- **Critical (Score 9)**: 7
- **High (Score 6)**: 6
- **Medium (Score 4)**: 8
- **Low (Score 2-3)**: 2

**Estimated Rework Effort**: 10-15 days

### Critical Flaws Identified

#### 1. Mathematical Failures (3 Critical Risks)

**MATH-001: Weight Normalization Failure**
- No validation that retrieved weights sum to 1.0
- Enables composite scores >1.0 or <0.0
- Silent data corruption in production
- **Mitigation**: Add validation before using weights

**MATH-002: EVS Normalization Loses Information**
- Linear capping `min(ratio/5, 1)` treats 10× viral = 5× viral
- Loses critical information about mega-viral posts
- Learning system cannot optimize for true virality
- **Mitigation**: Use logarithmic/sigmoid scaling or categorical approach

**MATH-003: No Uncertainty Quantification**
- All decisions are point estimates
- Cannot express confidence or identify near-threshold decisions
- No support for A/B testing or causal inference
- **Mitigation**: Add Bayesian approach with credible intervals

#### 2. Statistical Failures (2 Critical Risks)

**STAT-001: Arbitrary Thresholds**
- SSS ≥ 0.82, 0.55 ≤ SSS < 0.82, EVS > 5.0, EVS > 2.0, ARS > 0.70
- All thresholds lack statistical justification or data-driven rationale
- No power analysis for sample size threshold of 50
- **Mitigation**: Document rationale OR make configurable OR use calibrated probability model

**STAT-002: Sample Size Threshold Lacks Power Analysis**
- Threshold of 50 is arbitrary
- No calculation of required sample size for reliable weight estimation
- **Mitigation**: Conduct power analysis OR implement Bayesian shrinkage

#### 3. Architectural Failures (2 Critical Risks)

**ARCH-001: Linear Combination Ignores Interaction Effects**
- Assumes signal independence: `composite = SSS×w1 + ARS×w2 + EVS×w3 + TRS×w4`
- Real-world interactions: high SSS + high ARS is multiplicatively valuable
- Linear model misses "perfect storm" opportunities
- **Mitigation**: Add interaction terms OR use logistic regression

**ARCH-002: Mode Selection Logic Has Gaps**
- Power user check only in mid SSS band (0.55-0.82)
- Inconsistent EVS thresholds across SSS bands
- Missing low-SSS power user handling
- **Mitigation**: Refactor with clear priority ordering

#### 4. Performance Failures (2 High Risks)

**PERF-001: No Weight Caching**
- 3 database queries per decision (combined, platform, global fallback)
- 200-300ms latency overhead
- P95 decision latency: 400-600ms vs 500ms target
- **Mitigation**: Implement node-cache with 10-minute TTL

**PERF-002: Missing Database Indexes**
- `segmented_weights` lookup will degrade as data grows
- `decisions` queries will slow down
- N+1 archetype lookups
- **Mitigation**: Add indexes and cache archetype IDs

#### 5. Reliability Failures (2 High Risks)

**REL-001: No Error Boundaries**
- Single signal analyzer failure crashes entire decision
- No graceful degradation
- No fallback values
- **Mitigation**: Wrap signal fetches with error boundaries

**REL-002: No Circuit Breakers**
- No protection against cascading failures
- No retry logic for transient failures
- No health checks
- **Mitigation**: Implement circuit breakers using opossum library

#### 6. Data Quality Failures (2 High Risks)

**DATA-001: No Composite Score Validation**
- Invalid weights could produce scores >1.0
- Breaks mode selection logic
- **Mitigation**: Add range validation and clamping

**DATA-002: No NaN/Infinity Handling**
- API failures returning NaN would crash calculation
- No protection against numerical instability
- **Mitigation**: Add validation and safe fallbacks

### Test Design Assessment

**Test Coverage**: 147 explicit scenarios + 4,480 exhaustive matrix combinations + property-based tests

**Strengths**:
- Comprehensive mode selection matrix (all combinations tested)
- Property-based tests for mathematical invariants
- Chaos/failure injection for robustness
- Performance SLA validation

**Test Files Created**:
- Unit tests: 89 scenarios (60.5%)
- Integration tests: 48 scenarios (32.7%)
- E2E tests: 10 scenarios (6.8%)

**Gap**: Tests expose flaws (as intended), but code must be fixed first.

### NFR Assessment

**Security: CONCERNS**
- Missing input validation at entry point
- No rate limiting on decision engine invocations
- Weight poisoning protection needed

**Performance: FAIL**
- No caching → 200-300ms overhead per decision
- Missing critical indexes
- N+1 archetype queries
- P95 latency 400-600ms vs 500ms target

**Reliability: FAIL**
- No error boundaries
- No circuit breakers
- No retry logic
- No health checks
- Single point of failure in signal fetching

**Maintainability: CONCERNS**
- Mathematical formulas undocumented
- No Architecture Decision Records (ADRs)
- No versioning strategy
- Test coverage 60-70% vs 90% target

### Compliance Check

- [ ] **Mathematical Soundness**: FAIL - Weight validation, EVS normalization, uncertainty quantification all missing
- [ ] **Statistical Rigor**: FAIL - Arbitrary thresholds, no power analysis
- [ ] **Architectural Robustness**: FAIL - No interaction effects, logic gaps
- [x] **Coding Standards**: PASS - Follows TypeScript strict mode, ESLint
- [ ] **Performance SLAs**: FAIL - Latency target not met, no caching
- [ ] **Reliability Requirements**: FAIL - No error boundaries, circuit breakers
- [ ] **Testing Strategy**: PASS - Comprehensive test design (but code must be fixed first)
- [x] **All ACs Met (Functionally)**: PASS - ACs covered, but implementation flawed

### Improvements Checklist

**BLOCKING (Must Fix Before Implementation)**:

#### Mathematical Validation Layer
- [ ] Add weight validation (sum = 1.0 ± 0.001, non-negative)
- [ ] Add composite score range validation and clamping
- [ ] Add NaN/Infinity handling for all signals
- [ ] Replace EVS linear capping with logarithmic scaling
- [ ] Implement Bayesian uncertainty quantification (credible intervals, mode probabilities)

**Estimated Effort**: 3-4 days

#### Statistical Rigor
- [ ] Document rationale for all thresholds (0.82, 0.55, 5.0, 2.0, 0.70, 50)
- [ ] OR make thresholds configurable for A/B testing
- [ ] Conduct power analysis for sample size threshold
- [ ] OR implement Bayesian shrinkage for small samples

**Estimated Effort**: 2-3 days

#### Architectural Improvements
- [ ] Add interaction terms (at minimum: SSS × ARS, EVS × TRS)
- [ ] OR train logistic regression model to learn interactions
- [ ] Refactor mode selection with clear priority ordering
- [ ] Fix power user logic gaps

**Estimated Effort**: 2-3 days

#### Performance Optimization
- [ ] Implement weight caching with node-cache (10-minute TTL)
- [ ] Add database indexes (segmented_weights, decisions)
- [ ] Cache archetype ID mapping to eliminate N+1 queries

**Estimated Effort**: 0.5-1 day

#### Reliability Hardening
- [ ] Add error boundaries with fallback values for signal fetches
- [ ] Implement circuit breakers (opossum library)
- [ ] Add retry logic with exponential backoff
- [ ] Implement health check endpoint
- [ ] Add metrics/monitoring hooks

**Estimated Effort**: 2-3 days

**NON-BLOCKING (Should Fix Post-Implementation)**:

- [ ] Add input validation with Zod schemas
- [ ] Implement rate limiting
- [ ] Add comprehensive JSDoc with mathematical explanations
- [ ] Create Architecture Decision Records (ADRs)
- [ ] Add decision logic versioning
- [ ] Implement A/B testing framework

**Estimated Effort**: 3-4 days

### Files Modified During Review

None (pre-implementation review - no code changes made)

### Supporting Documentation

**Comprehensive Assessments Created**:

1. **Risk Profile** (23 risks identified):
   - Path: `docs/qa/assessments/2.5-risk-20251206.md`
   - Contains: Detailed analysis of all 23 risks with probability×impact scoring, mitigation strategies, and testing requirements

2. **Test Design** (147 scenarios):
   - Path: `docs/qa/assessments/2.5-test-design-20251206.md`
   - Contains: Exhaustive test matrix, property-based tests, chaos engineering scenarios, performance benchmarks

3. **NFR Assessment** (Security/Performance/Reliability/Maintainability):
   - Path: `docs/qa/assessments/2.5-nfr-20251206.md`
   - Contains: Detailed analysis of non-functional requirements with checklists and recommendations

4. **Quality Gate Decision**:
   - Path: `docs/qa/gates/2.5-decision-score-calculation-mode-selection.yml`
   - Contains: Formal gate decision with top issues, recommendations, and estimated rework effort

### Gate Status

**Gate**: **FAIL** → `docs/qa/gates/2.5-decision-score-calculation-mode-selection.yml`

**Risk Profile**: `docs/qa/assessments/2.5-risk-20251206.md`
**Test Design**: `docs/qa/assessments/2.5-test-design-20251206.md`
**NFR Assessment**: `docs/qa/assessments/2.5-nfr-20251206.md`

**Quality Score**: 21/100
**Expires**: 2025-12-20

### Recommended Status

[✗ **REQUIRES MAJOR REVISION** - DO NOT IMPLEMENT AS-IS]

**Recommendation**: Revise story with improved mathematical foundations, statistical rigor, and architectural robustness. Estimated 10-15 days of additional design/implementation work required to reach production-ready state.

**Next Steps**:
1. Review comprehensive risk profile and NFR assessment
2. Decide on approach for each critical issue (implement mitigations vs alternative design)
3. Update story with revised implementation incorporating fixes
4. Re-submit for QA gate review after revisions complete

**Owner Decision Required**: Story owner must decide whether to:
- **Option A**: Implement all critical mitigations (10-15 days) then proceed
- **Option B**: Redesign with simpler approach (e.g., fixed thresholds, no segmented weights) for MVP
- **Option C**: Escalate to architecture team for fundamental redesign consultation