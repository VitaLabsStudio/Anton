# Story 2.4: Signal 4 - Semantic Topic Filter

## Status: Draft

## Story

**As a** the decision engine,  
**I want** to filter out posts using hangover keywords metaphorically (movies, memes, work stress),  
**so that** I disengage from irrelevant contexts and avoid embarrassing misinterpretations.

## Acceptance Criteria

1. Module created at `@backend/analysis/signal-4-semantic.ts`
2. **DeepSeek R1 API integration** for topic classification with GPT-4 fallback:
   - Primary: DeepSeek R1 for semantic topic detection
   - Fallback: GPT-4 if DeepSeek fails
   - Processing: Parallel with Signal 1 for efficiency
3. Examples from project brief incorporated (e.g., "John Wick movie hangover" → "Movie Marathon" → disengage)
4. Topic Relevance Score (TRS) returned: 1.0 (actual hangover), 0.0 (metaphor/unrelated)
5. Named Entity Recognition (NER) detects movie/song titles (capitalized phrases)
6. Metaphor patterns detected: "inbox hangover", "crypto hangover", "meeting nausea"
7. Function executes in <2 seconds (parallel with Signal 1 if possible)
8. Unit tests with 30+ metaphor examples achieve >90% accuracy
9. Ambiguous cases (0.4-0.6) logged for human review

---

## Tasks / Subtasks

- [ ] **Task 1: Create Semantic Topic Module** (AC: 1, 4)
  - [ ] Create `backend/src/analysis/signal-4-semantic.ts`
  - [ ] Implement `analyzeSemanticTopic(content: string)` function
  - [ ] Return TRS score (1.0 = relevant, 0.0 = metaphor)
  - [ ] Include detected context in result

- [ ] **Task 2: Implement DeepSeek Integration** (AC: 2, 3)
  - [ ] Reuse DeepSeekClient from Signal 1
  - [ ] Build prompt for topic classification
  - [ ] Include metaphor examples from project brief
  - [ ] Parse binary result (actual hangover vs metaphor)

- [ ] **Task 3: Implement Named Entity Recognition** (AC: 5)
  - [ ] Detect capitalized phrases (movie/song titles)
  - [ ] Pattern: "The [Capitalized Title]" + (movie|film|song|album)
  - [ ] Flag as metaphor if detected

- [ ] **Task 4: Implement Metaphor Pattern Detection** (AC: 6)
  - [ ] Pattern list: "inbox hangover", "crypto hangover", "meeting nausea"
  - [ ] Detect work stress metaphors
  - [ ] Detect pop culture references
  - [ ] Flag as metaphor if matched

- [ ] **Task 5: Implement Ambiguity Logging** (AC: 9)
  - [ ] Log cases with TRS 0.4-0.6
  - [ ] Include full context for human review
  - [ ] Track ambiguity rate metric

- [ ] **Task 6: Optimize for Parallel Processing** (AC: 7)
  - [ ] Design for Promise.all with Signal 1
  - [ ] Share DeepSeek client instance
  - [ ] Ensure <2s processing time

- [ ] **Task 7: Write Unit Tests** (AC: 8)
  - [ ] Test 30+ metaphor examples
  - [ ] Test actual hangover posts (TRS = 1.0)
  - [ ] Test movie/song metaphors (TRS = 0.0)
  - [ ] Test work stress metaphors
  - [ ] Verify >90% accuracy

---

## Dev Notes

### Previous Story Insights
- Story 2.1 complete (DeepSeekClient available for reuse)
- This signal runs in parallel with Signal 1 for efficiency

### Semantic Topic Filter Implementation
```typescript
// backend/src/analysis/signal-4-semantic.ts

import { DeepSeekClient } from '../clients/deepseek';
import { logger } from '../utils/logger';
import { createHash } from 'crypto';
import NodeCache from 'node-cache';

interface SignalResult {
  score: number; // TRS: 1.0 = actual hangover, 0.0 = metaphor
  confidence: number;
  context: 'actual_hangover' | 'metaphor' | 'ambiguous';
  detectedPattern?: string;
}

const cache = new NodeCache({ stdTTL: 7 * 24 * 60 * 60 }); // 7 days

const METAPHOR_PATTERNS = [
  /inbox hangover/i,
  /crypto hangover/i,
  /bitcoin hangover/i,
  /ethereum hangover/i,
  /market hangover/i,
  /meeting (hangover|nausea)/i,
  /work (hangover|stress)/i,
  /exam (hangover|stress)/i,
  /election hangover/i,
  /emotional hangover/i,
];

export class SemanticTopicAnalyzer {
  private deepseek: DeepSeekClient;

  constructor() {
    this.deepseek = new DeepSeekClient();
  }

  async analyzeSemanticTopic(content: string): Promise<SignalResult> {
    // Check cache
    const cacheKey = this.getCacheKey(content);
    const cached = cache.get<SignalResult>(cacheKey);
    if (cached) {
      logger.debug('TRS cache hit', { cacheKey });
      return cached;
    }

    try {
      // Quick pattern-based detection
      const patternResult = this.detectMetaphorPatterns(content);
      if (patternResult) {
        cache.set(cacheKey, patternResult);
        return patternResult;
      }

      // NER for movie/song titles
      const nerResult = this.detectNamedEntities(content);
      if (nerResult) {
        cache.set(cacheKey, nerResult);
        return nerResult;
      }

      // DeepSeek semantic classification
      const prompt = this.buildPrompt(content);
      const result = await this.deepseek.generate(prompt, {
        temperature: 0.2,
        maxTokens: 150,
      });

      const parsed = this.parseResponse(result.content);

      const signalResult: SignalResult = {
        score: parsed.isActualHangover ? 1.0 : 0.0,
        confidence: result.confidence,
        context: parsed.isActualHangover ? 'actual_hangover' : 'metaphor',
      };

      // Log ambiguous cases
      if (parsed.ambiguity && parsed.ambiguity > 0.4) {
        logger.warn('Ambiguous topic detected', {
          content,
          score: signalResult.score,
          ambiguity: parsed.ambiguity,
        });
      }

      cache.set(cacheKey, signalResult);
      return signalResult;
    } catch (error) {
      logger.error('Semantic topic analysis failed', { error });
      // Default to relevant (conservative - let other signals decide)
      return {
        score: 1.0,
        confidence: 0.0,
        context: 'ambiguous',
      };
    }
  }

  private detectMetaphorPatterns(content: string): SignalResult | null {
    for (const pattern of METAPHOR_PATTERNS) {
      if (pattern.test(content)) {
        return {
          score: 0.0,
          confidence: 0.95,
          context: 'metaphor',
          detectedPattern: pattern.source,
        };
      }
    }
    return null;
  }

  private detectNamedEntities(content: string): SignalResult | null {
    // Detect patterns like "The [Title]" + movie/film/song/album
    const moviePattern = /(?:The|A)\s+([A-Z][a-zA-Z\s]+)\s+(?:movie|film|soundtrack|album)/i;
    const match = content.match(moviePattern);

    if (match) {
      return {
        score: 0.0,
        confidence: 0.90,
        context: 'metaphor',
        detectedPattern: `Movie/media reference: ${match[1]}`,
      };
    }

    return null;
  }

  private buildPrompt(content: string): string {
    return `
Determine if this post is about an ACTUAL alcohol hangover or using "hangover" metaphorically.

POST:
"${content}"

ACTUAL HANGOVER (return 1.0):
- Physical symptoms from alcohol consumption
- Morning after drinking
- Seeking hangover remedies
Examples:
- "This headache is brutal. What helps hangovers?"
- "Woke up nauseous and dizzy after last night"
- "Too much tequila. I need help."

METAPHOR/UNRELATED (return 0.0):
- Movie marathons ("movie hangover")
- Work stress ("inbox hangover", "meeting nausea")
- Cryptocurrency ("crypto hangover", "bitcoin crash")
- Emotional states not related to alcohol
- Song/album titles ("The Hangover" soundtrack)
Examples:
- "Just finished a John Wick movie hangover"
- "My inbox hangover is real after vacation"
- "Bitcoin hangover after the crash"
- "Election hangover - so much stress"

Respond with JSON:
{
  "isActualHangover": true|false,
  "confidence": 0.0-1.0,
  "reasoning": "brief explanation",
  "ambiguity": 0.0-1.0 (how unclear is this case?)
}`;
  }

  private parseResponse(content: string): {
    isActualHangover: boolean;
    ambiguity?: number;
  } {
    try {
      const parsed = JSON.parse(content);
      return {
        isActualHangover: parsed.isActualHangover,
        ambiguity: parsed.ambiguity,
      };
    } catch (error) {
      logger.error('Failed to parse DeepSeek response', { content });
      // Default to actual hangover (conservative)
      return { isActualHangover: true };
    }
  }

  private getCacheKey(content: string): string {
    return createHash('md5').update(content).digest('hex');
  }
}

// Export singleton
export const semanticTopicAnalyzer = new SemanticTopicAnalyzer();
export const analyzeSemanticTopic = (content: string) =>
  semanticTopicAnalyzer.analyzeSemanticTopic(content);
```

### Metaphor Examples to Test
[Source: project brief]

**Movie/Media References (TRS = 0.0):**
- "Just had a John Wick movie hangover"
- "The Hangover Part 2 is on Netflix"
- "Binge-watching hangover is real"

**Work/Tech Metaphors (TRS = 0.0):**
- "Inbox hangover after vacation"
- "Crypto hangover from the crash"
- "Meeting nausea from back-to-back calls"
- "Election hangover still hitting"

**Actual Hangovers (TRS = 1.0):**
- "Headache won't go away. Drank too much last night"
- "Nauseous and dizzy. What helps with hangovers?"
- "Rough morning after the party. Need advice"

### File Structure
```
backend/src/
├── clients/
│   └── deepseek.ts
└── analysis/
    ├── signal-1-linguistic.ts
    ├── signal-2-author.ts
    ├── signal-3-velocity.ts
    └── signal-4-semantic.ts      # TRS analyzer
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/signal-4-semantic.test.ts`

### Testing Standards
- Mock DeepSeek client responses
- Test all metaphor patterns
- Test NER detection
- Verify >90% accuracy on 30+ examples

### Story-Specific Testing Requirements
1. Movie/media references return TRS = 0.0
2. Work/tech metaphors return TRS = 0.0
3. Actual hangovers return TRS = 1.0
4. Ambiguous cases (0.4-0.6) are logged
5. Processing time <2s
6. NER detects capitalized titles
7. Pattern matching catches common metaphors

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

