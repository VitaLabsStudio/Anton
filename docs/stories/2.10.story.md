# Story 2.10: Archetype Selection Engine

## Status: Draft

## Story

**As a** the decision engine,  
**I want** a formalized archetype selection algorithm based on mode, author context, and post content,  
**so that** archetypes are chosen systematically rather than randomly, optimizing for engagement.

## Acceptance Criteria

1. Module created at `@backend/generation/archetype-selector.ts`
2. **Mode-Based Archetype Pool** defined:
   - **Helpful Mode** → Checklist, Coach, Credibility-anchor, Confident Recommender, Problem-Solution Direct
   - **Engagement Mode** → Humor-light, Storylet (no product mention)
   - **Hybrid Mode** → Myth-bust, Storylet, Coach, Confident Recommender (soft mention)
3. **Author Context Refinement**:
   - Healthcare professional detected → Credibility-anchor preferred (2× weight)
   - Parent/Family → Coach or Storylet
   - Young adult/Student (age <25 inferred) → Humor-light, Storylet
   - Comedian/Creative (bio contains "comedian", "artist") → Humor-light
4. **Content Triggers** (override priority):
   - Post contains misinformation → **Myth-bust** (mandatory)
   - Post asks "does X work?" → **Credibility-anchor** or **Problem-Solution Direct**
   - Post expresses desperation ("help", "desperate") → **Checklist** or **Coach**
   - Post is joking/venting (no question marks) → **Humor-light** or **Storylet**
5. **Rotation Enforcement**:
   - Track last 10 archetypes used globally in memory cache or Redis
   - Never repeat same archetype within 10 consecutive replies
   - Exception: Myth-bust can interrupt rotation anytime (override flag)
   - Implementation: `archetypeRotation.canUse(archetype)` returns boolean
6. **Power User Override**:
   - Users with >5k followers → Use ONLY top 3 performing archetypes
   - Verified badges → Prefer **Confident Recommender** or **Credibility-anchor**
7. Function returns: `{archetype: "Checklist", reason: "Helpful mode + desperation detected", confidence: 0.92}`
8. Archetype performance tracked per decision for learning loop
9. Unit tests validate selection logic for 30+ scenario combinations
10. Dashboard shows archetype distribution and performance comparison

---

## Tasks / Subtasks

- [ ] **Task 1: Create Archetype Selector Module** (AC: 1, 7)
  - [ ] Create `backend/src/generation/archetype-selector.ts`
  - [ ] Implement selectArchetype() function
  - [ ] Return archetype with reasoning and confidence

- [ ] **Task 2: Define Mode-Based Pools** (AC: 2)
  - [ ] Define HELPFUL pool: [CHECKLIST, COACH, CREDIBILITY_ANCHOR, CONFIDENT_RECOMMENDER, PROBLEM_SOLUTION_DIRECT]
  - [ ] Define ENGAGEMENT pool: [HUMOR_LIGHT, STORYLET]
  - [ ] Define HYBRID pool: [MYTHBUST, STORYLET, COACH, CONFIDENT_RECOMMENDER]
  - [ ] Return pool based on mode

- [ ] **Task 3: Implement Author Context Refinement** (AC: 3)
  - [ ] Check author.archetypeTags for healthcare_pro
  - [ ] Check for parent/family tags
  - [ ] Infer age from bio or follower patterns
  - [ ] Check for comedian/creative
  - [ ] Apply 2× weight to preferred archetypes

- [ ] **Task 4: Implement Content Triggers** (AC: 4)
  - [ ] Detect misinformation → force MYTHBUST
  - [ ] Detect "does X work?" → prefer CREDIBILITY_ANCHOR
  - [ ] Detect desperation → prefer CHECKLIST or COACH
  - [ ] Detect joking → prefer HUMOR_LIGHT or STORYLET

- [ ] **Task 5: Implement Rotation Enforcement** (AC: 5)
  - [ ] Track last 10 archetypes in Redis or memory
  - [ ] Implement FIFO queue (max size 10)
  - [ ] Check canUse(archetype) before selection
  - [ ] Allow MYTHBUST to override rotation

- [ ] **Task 6: Implement Power User Override** (AC: 6)
  - [ ] Check if author is power user
  - [ ] Get top 3 performing archetypes from analytics
  - [ ] Restrict selection to top 3 only
  - [ ] Prefer CONFIDENT_RECOMMENDER for verified

- [ ] **Task 7: Create Performance Tracking** (AC: 8)
  - [ ] Store selected archetype in decision
  - [ ] Track for future learning (Epic 4)

- [ ] **Task 8: Create Dashboard API** (AC: 10)
  - [ ] Endpoint GET /api/analytics/archetypes
  - [ ] Return distribution by archetype
  - [ ] Return performance metrics per archetype
  - [ ] Compare engagement rates

- [ ] **Task 9: Write Unit Tests** (AC: 9)
  - [ ] Test 30+ scenario combinations
  - [ ] Test mode-based pool selection
  - [ ] Test author context refinement
  - [ ] Test content triggers
  - [ ] Test rotation enforcement
  - [ ] Test power user override

---

## Dev Notes

### Previous Story Insights
- Story 2.2 complete (author archetypes detected)
- Story 2.5 complete (mode selection done)
- Story 2.11 will provide power user detection

### Archetype Selector Implementation
```typescript
// backend/src/generation/archetype-selector.ts

import { OperationalMode, Archetype, Author, Post } from '@prisma/client';
import { logger } from '../utils/logger';
import Redis from 'ioredis';

interface ArchetypeSelection {
  archetype: Archetype;
  reason: string;
  confidence: number;
}

interface ArchetypeRotation {
  recent: Archetype[];
  maxSize: number;
}

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

const MODE_POOLS: Record<OperationalMode, Archetype[]> = {
  HELPFUL: [
    'CHECKLIST',
    'COACH',
    'CREDIBILITY_ANCHOR',
    'CONFIDENT_RECOMMENDER',
    'PROBLEM_SOLUTION_DIRECT',
  ],
  ENGAGEMENT: ['HUMOR_LIGHT', 'STORYLET'],
  HYBRID: ['MYTHBUST', 'STORYLET', 'COACH', 'CONFIDENT_RECOMMENDER'],
  DISENGAGED: [],
};

export class ArchetypeSelector {
  async selectArchetype(
    mode: OperationalMode,
    author: Author,
    post: Post,
    isPowerUser: boolean = false,
    competitorDetected: string | null = null
  ): Promise<ArchetypeSelection> {
    // Content trigger overrides (highest priority)
    const contentTrigger = this.checkContentTriggers(post.content);
    if (contentTrigger) {
      return {
        archetype: contentTrigger.archetype,
        reason: contentTrigger.reason,
        confidence: 0.95,
      };
    }

    // Get mode-based pool
    let pool = [...MODE_POOLS[mode]];
    if (pool.length === 0) {
      throw new Error(`No archetypes for mode: ${mode}`);
    }

    // Apply author context refinement
    pool = this.refineByAuthorContext(pool, author);

    // Apply power user override
    if (isPowerUser) {
      pool = await this.applyPowerUserFilter(pool);
    }

    // Filter by rotation (no repeats in last 10)
    pool = await this.filterByRotation(pool);

    // Select from pool
    const selected = this.selectFromPool(pool);

    // Update rotation
    await this.updateRotation(selected);

    return {
      archetype: selected,
      reason: this.buildReason(mode, author, isPowerUser),
      confidence: 0.85,
    };
  }

  private checkContentTriggers(content: string): ArchetypeSelection | null {
    // Misinformation detected → MYTHBUST
    if (this.detectMisinformation(content)) {
      return {
        archetype: 'MYTHBUST',
        reason: 'Misinformation detected in post content',
        confidence: 0.95,
      };
    }

    // "Does X work?" → CREDIBILITY_ANCHOR
    if (/does .+ work\?/i.test(content)) {
      return {
        archetype: 'CREDIBILITY_ANCHOR',
        reason: 'Efficacy question detected',
        confidence: 0.90,
      };
    }

    // Desperation → CHECKLIST or COACH
    if (/(desperate|help|please|urgent|need)/i.test(content)) {
      return {
        archetype: 'CHECKLIST',
        reason: 'Desperation/urgency detected',
        confidence: 0.88,
      };
    }

    return null;
  }

  private refineByAuthorContext(pool: Archetype[], author: Author): Archetype[] {
    const tags = author.archetypeTags || [];

    // Healthcare professional → Prefer CREDIBILITY_ANCHOR
    if (tags.includes('healthcare_pro')) {
      return this.boostArchetype(pool, 'CREDIBILITY_ANCHOR', 2);
    }

    // Parent/Family → Prefer COACH or STORYLET
    if (tags.includes('parent')) {
      return this.boostArchetypes(pool, ['COACH', 'STORYLET'], 2);
    }

    // Comedian → Prefer HUMOR_LIGHT
    if (tags.includes('comedian')) {
      return this.boostArchetype(pool, 'HUMOR_LIGHT', 2);
    }

    return pool;
  }

  private boostArchetype(pool: Archetype[], archetype: Archetype, times: number): Archetype[] {
    if (!pool.includes(archetype)) return pool;
    const boosted = [...pool];
    for (let i = 0; i < times - 1; i++) {
      boosted.push(archetype);
    }
    return boosted;
  }

  private boostArchetypes(pool: Archetype[], archetypes: Archetype[], times: number): Archetype[] {
    let boosted = [...pool];
    for (const archetype of archetypes) {
      boosted = this.boostArchetype(boosted, archetype, times);
    }
    return boosted;
  }

  private async applyPowerUserFilter(pool: Archetype[]): Promise<Archetype[]> {
    // Get top 3 performing archetypes from analytics
    const topPerformers = await this.getTopPerformingArchetypes(3);
    return pool.filter(a => topPerformers.includes(a));
  }

  private async filterByRotation(pool: Archetype[]): Promise<Archetype[]> {
    const recent = await this.getRecentArchetypes(10);
    return pool.filter(a => !recent.includes(a));
  }

  private selectFromPool(pool: Archetype[]): Archetype {
    if (pool.length === 0) {
      throw new Error('No available archetypes after filtering');
    }
    // Random selection from pool
    const index = Math.floor(Math.random() * pool.length);
    return pool[index];
  }

  private async updateRotation(archetype: Archetype): Promise<void> {
    await redis.lpush('archetype_rotation', archetype);
    await redis.ltrim('archetype_rotation', 0, 9); // Keep last 10
  }

  private async getRecentArchetypes(count: number): Promise<Archetype[]> {
    const recent = await redis.lrange('archetype_rotation', 0, count - 1);
    return recent as Archetype[];
  }

  private async getTopPerformingArchetypes(count: number): Promise<Archetype[]> {
    // Query analytics for top performers
    // TODO: Implement in Epic 4
    return ['CREDIBILITY_ANCHOR', 'CONFIDENT_RECOMMENDER', 'CHECKLIST'];
  }

  private detectMisinformation(content: string): boolean {
    const myths = [
      /activated charcoal cures? hangovers?/i,
      /coffee sobers? you up/i,
      /hair of the dog (works?|cures?)/i,
    ];
    return myths.some(pattern => pattern.test(content));
  }

  private buildReason(mode: OperationalMode, author: Author, isPowerUser: boolean): string {
    const parts = [`Mode: ${mode}`];
    if (author.archetypeTags.length > 0) {
      parts.push(`Author: ${author.archetypeTags.join(', ')}`);
    }
    if (isPowerUser) {
      parts.push('Power user optimization');
    }
    return parts.join('; ');
  }
}

// Export singleton
export const archetypeSelector = new ArchetypeSelector();
```

### File Structure
```
backend/src/
└── generation/
    └── archetype-selector.ts    # THIS STORY
```

---

## Testing

### Test File Location
- `backend/tests/unit/generation/archetype-selector.test.ts`

### Testing Standards
- Mock Redis
- Test all mode pools
- Test rotation enforcement

### Story-Specific Testing Requirements
1. Mode pools return correct archetypes
2. Healthcare pro gets CREDIBILITY_ANCHOR preference
3. Misinformation triggers MYTHBUST
4. Rotation prevents repeats within 10
5. Power users get top 3 only
6. Content triggers override other logic

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

