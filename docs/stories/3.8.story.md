# Story 3.8: Relationship Memory Updates

## Status: Draft

## Story

**As a** the system,  
**I want** to update author relationship scores based on post-reply outcomes,  
**so that** future interactions benefit from learned preferences and history.

## Acceptance Criteria

1. Relationship update service at `@backend/services/relationship-updater.ts`
2. Service runs hourly, processes posted replies with outcome data
3. Positive signals update author score:
   - "Thanks" in text response: +0.15
   - Like/upvote on reply: +0.05
   - Link click (UTM tracking): +0.10
   - Purchase attributed: +0.25
4. Negative signals update author score:
   - Block/mute: -0.30
   - Report: -0.40
   - Hostile text response: -0.20
5. Author archetypes updated based on new bio/post data
6. `authors` table `interaction_history` column stores interaction timeline
7. Relationship scores capped at 0.0-1.0 range
8. Unit tests validate score updates for various outcome scenarios
9. Dashboard shows author relationship score trends over time

---

## Tasks / Subtasks

- [ ] **Task 1: Create Relationship Updater Service** (AC: 1, 2)
  - [ ] Create `backend/src/services/relationship-updater.ts`
  - [ ] Run hourly loop
  - [ ] Query posted replies with outcomes
  - [ ] Update author scores

- [ ] **Task 2: Implement Positive Signal Detection** (AC: 3)
  - [ ] Detect "thanks" in responses (+0.15)
  - [ ] Track likes/upvotes (+0.05)
  - [ ] Track UTM clicks (+0.10)
  - [ ] Track purchases (+0.25)

- [ ] **Task 3: Implement Negative Signal Detection** (AC: 4)
  - [ ] Detect blocks/mutes (-0.30)
  - [ ] Detect reports (-0.40)
  - [ ] Detect hostile responses (-0.20)

- [ ] **Task 4: Update Author Scores** (AC: 7)
  - [ ] Calculate score adjustment
  - [ ] Update author.relationshipScore
  - [ ] Cap at 0.0-1.0

- [ ] **Task 5: Update Interaction History** (AC: 6)
  - [ ] Append event to interaction_history JSON
  - [ ] Include type, timestamp, context
  - [ ] Maintain chronological order

- [ ] **Task 6: Update Archetypes** (AC: 5)
  - [ ] Re-parse author bio
  - [ ] Update archetype_tags
  - [ ] Log changes

- [ ] **Task 7: Create Dashboard API** (AC: 9)
  - [ ] Endpoint GET /api/authors/:id/relationship-history
  - [ ] Return score over time
  - [ ] Return interaction timeline

- [ ] **Task 8: Write Unit Tests** (AC: 8)
  - [ ] Test all signal weights
  - [ ] Test score capping
  - [ ] Test interaction history updates

---

## Dev Notes

### Relationship Updater Implementation
```typescript
// backend/src/services/relationship-updater.ts

import { prisma } from '../db';
import { logger } from '../utils/logger';

const SIGNAL_WEIGHTS = {
  thanks: 0.15,
  like: 0.05,
  click: 0.10,
  purchase: 0.25,
  block: -0.30,
  report: -0.40,
  hostile: -0.20,
};

export class RelationshipUpdater {
  async start(): Promise<void> {
    logger.info('Relationship Updater starting');

    while (true) {
      try {
        await this.updateRelationships();
      } catch (error) {
        logger.error('Relationship update failed', { error });
      }

      await this.sleep(60 * 60 * 1000); // 1 hour
    }
  }

  private async updateRelationships(): Promise<void> {
    // Get replies posted in last 24 hours
    const replies = await prisma.reply.findMany({
      where: {
        postedAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
        },
      },
      include: {
        decision: {
          include: {
            post: {
              include: { author: true },
            },
          },
        },
      },
    });

    for (const reply of replies) {
      const author = reply.decision.post.author;
      const outcomes = await this.collectOutcomes(reply);

      let scoreAdjustment = 0;
      const events: any[] = [];

      // Positive signals
      if (outcomes.hasThanks) {
        scoreAdjustment += SIGNAL_WEIGHTS.thanks;
        events.push({ type: 'thanks', timestamp: new Date(), replyId: reply.id });
      }
      if (outcomes.likes > 0) {
        scoreAdjustment += SIGNAL_WEIGHTS.like * outcomes.likes;
        events.push({ type: 'like', timestamp: new Date(), count: outcomes.likes });
      }
      if (outcomes.clicks > 0) {
        scoreAdjustment += SIGNAL_WEIGHTS.click;
        events.push({ type: 'click', timestamp: new Date(), utmCode: reply.utmCode });
      }
      if (outcomes.purchase) {
        scoreAdjustment += SIGNAL_WEIGHTS.purchase;
        events.push({ type: 'purchase', timestamp: new Date() });
      }

      // Negative signals
      if (outcomes.blocked) {
        scoreAdjustment += SIGNAL_WEIGHTS.block;
        events.push({ type: 'block', timestamp: new Date() });
      }
      if (outcomes.reported) {
        scoreAdjustment += SIGNAL_WEIGHTS.report;
        events.push({ type: 'report', timestamp: new Date() });
      }
      if (outcomes.hostile) {
        scoreAdjustment += SIGNAL_WEIGHTS.hostile;
        events.push({ type: 'hostile_reply', timestamp: new Date() });
      }

      // Update author if changes
      if (scoreAdjustment !== 0 || events.length > 0) {
        await this.updateAuthor(author, scoreAdjustment, events);
      }
    }
  }

  private async updateAuthor(author: any, adjustment: number, events: any[]): Promise<void> {
    const newScore = Math.max(0, Math.min(1, author.relationshipScore + adjustment));
    
    const currentHistory = author.interactionHistory as any[] || [];
    const updatedHistory = [...currentHistory, ...events];

    await prisma.author.update({
      where: { id: author.id },
      data: {
        relationshipScore: newScore,
        interactionHistory: updatedHistory,
        lastSeenAt: new Date(),
      },
    });

    logger.info('Author relationship updated', {
      authorId: author.id,
      oldScore: author.relationshipScore,
      newScore,
      adjustment,
      events: events.length,
    });
  }

  private async collectOutcomes(reply: any): Promise<any> {
    // Collect outcome signals from various sources
    // TODO: Implement based on platform APIs and analytics
    return {
      hasThanks: false,
      likes: 0,
      clicks: 0,
      purchase: false,
      blocked: false,
      reported: false,
      hostile: false,
    };
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export const relationshipUpdater = new RelationshipUpdater();
```

### File Structure
```
backend/src/
└── services/
    ├── queue-processor.ts
    ├── self-correction.ts
    └── relationship-updater.ts  # THIS STORY
```

---

## Testing

### Test File Location
- `backend/tests/unit/services/relationship-updater.test.ts`

### Testing Standards
- Mock outcome data
- Test all signal weights
- Test score capping

### Story-Specific Testing Requirements
1. Thanks increases score by 0.15
2. Purchase increases by 0.25
3. Block decreases by 0.30
4. Score stays in 0.0-1.0 range
5. Interaction history updated
6. Multiple events cumulative

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

