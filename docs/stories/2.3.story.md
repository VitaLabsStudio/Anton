# Story 2.3: Signal 3 - Post Metrics & Velocity Calculator

## Status: Draft

## Story

**As a** the decision engine,  
**I want** to analyze post engagement metrics relative to author baseline,  
**so that** I can calculate an Engagement Velocity Score (EVS) distinguishing private pleas from viral performances.

## Acceptance Criteria

1. Module created at `@backend/analysis/signal-3-velocity.ts`
2. Post metrics fetched from platform APIs (likes, replies, retweets/reposts)
3. Author baseline calculated from recent post history using **Robust Statistics** (Winsorized mean) to prevent skew from viral outliers
4. Velocity score = (current engagement rate) / (baseline rate)
5. EVS categories: silent plea (<1.0×), normal (1.0-2.0×), moderate (2.0-5.0×), viral (>5.0×)
6. Temporal context considered (post age, time of day, day of week)
7. Function returns EVS as float (ratio value, e.g., 0.5 or 8.3)
8. Unit tests with mock post data validate velocity calculation
9. Missing baseline (new author) defaults to EVS = 1.0

---

## Tasks / Subtasks

- [ ] **Task 1: Create Velocity Calculator Module** (AC: 1, 7)
  - [ ] Create `backend/src/analysis/signal-3-velocity.ts`
  - [ ] Implement `analyzePostVelocity(post, author)` function
  - [ ] Return SignalResult with EVS ratio
  - [ ] Include velocity category in result

- [ ] **Task 2: Fetch Post Metrics** (AC: 2)
  - [ ] Extract metrics from `post.rawMetrics` JSON
  - [ ] Parse likes, replies, retweets/reposts
  - [ ] Calculate engagement rate (total engagements / time elapsed)
  - [ ] Handle missing metrics gracefully

- [ ] **Task 3: Implement Robust Statistics** (AC: 3)
  - [ ] Create `backend/src/utils/robust-statistics.ts`
  - [ ] Implement Winsorized mean calculation
  - [ ] Implement Tukey's method for outlier detection
  - [ ] Apply to baseline calculation

- [ ] **Task 4: Calculate Author Baseline** (AC: 3, 9)
  - [ ] Query author's recent posts (last 20-50 posts)
  - [ ] Calculate engagement rate for each
  - [ ] Use Winsorized mean (exclude outliers)
  - [ ] Default to 1.0 if insufficient data (<5 posts)

- [ ] **Task 5: Calculate Velocity Ratio** (AC: 4, 5)
  - [ ] Current rate / baseline rate
  - [ ] Categorize: <1.0 (silent), 1.0-2.0 (normal), 2.0-5.0 (moderate), >5.0 (viral)
  - [ ] Return raw ratio value

- [ ] **Task 6: Consider Temporal Context** (AC: 6)
  - [ ] Factor post age into engagement rate
  - [ ] Normalize by time of day patterns
  - [ ] Account for day of week differences

- [ ] **Task 7: Write Unit Tests** (AC: 8)
  - [ ] Test velocity calculation with mock data
  - [ ] Test all categories (silent, normal, moderate, viral)
  - [ ] Test new author handling (default 1.0)
  - [ ] Test robust statistics outlier handling

---

## Dev Notes

### Previous Story Insights
- Story 2.1 and 2.2 complete (signal analyzer patterns)
- Story 1.3 complete (database with posts and authors)

### Velocity Calculator Implementation
[Source: architecture.md#7.2-core-domain-modules]

```typescript
// backend/src/analysis/signal-3-velocity.ts

import { prisma } from '../db';
import { Post, Author } from '@prisma/client';
import { winsorizedMean, detectOutliers } from '../utils/robust-statistics';
import { logger } from '../utils/logger';

interface SignalResult {
  ratio: number;  // Velocity ratio (not 0-1, can be >1)
  category: 'silent_plea' | 'normal' | 'moderate' | 'viral';
  confidence: number;
  baselineRate: number;
  currentRate: number;
}

export class PostVelocityAnalyzer {
  async analyzePostVelocity(post: Post, author: Author): Promise<SignalResult> {
    try {
      // Calculate current post's engagement rate
      const currentRate = this.calculateEngagementRate(post);

      // Get author's baseline from recent posts
      const baseline = await this.getAuthorBaseline(author.id, post.platform);

      // Calculate velocity ratio
      const ratio = baseline > 0 ? currentRate / baseline : 1.0;

      // Categorize velocity
      const category = this.categorizeVelocity(ratio);

      return {
        ratio,
        category,
        confidence: baseline > 0 ? 0.9 : 0.5, // Lower confidence for new authors
        baselineRate: baseline,
        currentRate,
      };
    } catch (error) {
      logger.error('Post velocity analysis failed', { error, postId: post.id });
      // Default to normal velocity on error
      return {
        ratio: 1.0,
        category: 'normal',
        confidence: 0.0,
        baselineRate: 0,
        currentRate: 0,
      };
    }
  }

  private calculateEngagementRate(post: Post): number {
    const metrics = post.rawMetrics as any;
    if (!metrics) return 0;

    const totalEngagement = 
      (metrics.likes || 0) + 
      (metrics.replies || 0) + 
      (metrics.retweets || metrics.reposts || 0);

    // Calculate hours since post
    const hoursSincePost = (Date.now() - post.detectedAt.getTime()) / (1000 * 60 * 60);
    const hoursElapsed = Math.max(0.25, hoursSincePost); // Min 15 minutes

    // Engagement per hour
    return totalEngagement / hoursElapsed;
  }

  private async getAuthorBaseline(authorId: string, platform: string): Promise<number> {
    // Get author's recent posts (last 20-50)
    const recentPosts = await prisma.post.findMany({
      where: {
        authorId,
        platform,
        detectedAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days
        },
      },
      orderBy: { detectedAt: 'desc' },
      take: 50,
    });

    if (recentPosts.length < 5) {
      // Insufficient data - return 1.0 baseline
      return 1.0;
    }

    // Calculate engagement rates for all posts
    const engagementRates = recentPosts.map(post => 
      this.calculateEngagementRate(post)
    );

    // Use Winsorized mean to exclude outliers
    const baseline = winsorizedMean(engagementRates, 0.10); // Trim 10% from each end

    return baseline || 1.0;
  }

  private categorizeVelocity(ratio: number): 'silent_plea' | 'normal' | 'moderate' | 'viral' {
    if (ratio < 1.0) return 'silent_plea';
    if (ratio < 2.0) return 'normal';
    if (ratio < 5.0) return 'moderate';
    return 'viral';
  }
}

// Export singleton
export const postVelocityAnalyzer = new PostVelocityAnalyzer();
export const analyzePostVelocity = (post: Post, author: Author) =>
  postVelocityAnalyzer.analyzePostVelocity(post, author);
```

### Robust Statistics Implementation
[Source: architecture.md#7.4-advanced-learning-system-architecture]

```typescript
// backend/src/utils/robust-statistics.ts

/**
 * Winsorized Mean: Replace outliers with nearest non-outlier values
 * @param values Array of numeric values
 * @param percentile Fraction to trim from each end (e.g., 0.10 = 10%)
 */
export function winsorizedMean(values: number[], percentile: number = 0.10): number {
  if (values.length === 0) return 0;
  if (values.length === 1) return values[0];

  // Sort values
  const sorted = [...values].sort((a, b) => a - b);

  // Calculate trim indices
  const trimCount = Math.floor(sorted.length * percentile);
  const lowerBound = sorted[trimCount];
  const upperBound = sorted[sorted.length - trimCount - 1];

  // Winsorize: replace outliers with bounds
  const winsorized = sorted.map(val => {
    if (val < lowerBound) return lowerBound;
    if (val > upperBound) return upperBound;
    return val;
  });

  // Calculate mean
  const sum = winsorized.reduce((acc, val) => acc + val, 0);
  return sum / winsorized.length;
}

/**
 * Tukey's Method for outlier detection
 * @param values Array of numeric values
 * @returns Indices of outliers
 */
export function detectOutliers(values: number[]): number[] {
  if (values.length < 4) return [];

  const sorted = [...values].sort((a, b) => a - b);
  const q1Index = Math.floor(sorted.length * 0.25);
  const q3Index = Math.floor(sorted.length * 0.75);

  const q1 = sorted[q1Index];
  const q3 = sorted[q3Index];
  const iqr = q3 - q1;

  const lowerFence = q1 - 1.5 * iqr;
  const upperFence = q3 + 1.5 * iqr;

  const outlierIndices: number[] = [];
  values.forEach((val, idx) => {
    if (val < lowerFence || val > upperFence) {
      outlierIndices.push(idx);
    }
  });

  return outlierIndices;
}

/**
 * Calculate standard deviation
 */
export function standardDeviation(values: number[]): number {
  const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
  const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
  const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  return Math.sqrt(variance);
}
```

### Velocity Categories
| Ratio | Category | Description | Example |
|-------|----------|-------------|---------|
| <1.0× | Silent Plea | Below author baseline, private post | 0.3× = Getting 30% of usual engagement |
| 1.0-2.0× | Normal | Within normal range | 1.5× = Slightly above average |
| 2.0-5.0× | Moderate | Higher than usual | 3.0× = 3× more engagement than typical |
| >5.0× | Viral | Significantly viral | 8.0× = Viral, 8× normal engagement |

### Post Metrics Schema
```typescript
// post.rawMetrics JSON structure
{
  "likes": 150,
  "replies": 23,
  "retweets": 45,  // Twitter
  "reposts": 45,    // Threads
  "upvotes": 120,   // Reddit
  "comments": 34    // Reddit
}
```

### File Structure
```
backend/src/
├── analysis/
│   ├── signal-1-linguistic.ts
│   ├── signal-2-author.ts
│   └── signal-3-velocity.ts     # EVS analyzer
└── utils/
    └── robust-statistics.ts     # Winsorized mean, Tukey's method
```

---

## Testing

### Test File Location
- `backend/tests/unit/analysis/signal-3-velocity.test.ts`
- `backend/tests/unit/utils/robust-statistics.test.ts`

### Testing Standards
- Mock Prisma queries for recent posts
- Test velocity categories
- Test robust statistics functions
- Verify outlier handling

### Story-Specific Testing Requirements
1. Silent plea posts (<1.0×) categorized correctly
2. Viral posts (>5.0×) categorized correctly
3. Winsorized mean excludes outliers
4. New authors default to EVS = 1.0
5. Engagement rate calculated correctly
6. Temporal factors applied appropriately

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-01 | 1.0 | Initial story draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*

